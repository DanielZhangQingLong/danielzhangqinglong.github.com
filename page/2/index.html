<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Hexo</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'uSvyVbAJs-5jfXFawgQ3','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/04/sidekiq/" itemprop="url">
                  Rails使用sidekiq进行异步任务处理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-04T08:34:50+08:00" content="2015-04-04">
              2015-04-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Rails/" itemprop="url" rel="index">
                    <span itemprop="name">Rails</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="sidekiq的使用方法"><a href="#sidekiq的使用方法" class="headerlink" title="sidekiq的使用方法"></a>sidekiq的使用方法</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote>
<p>首先, sidekiq使用的是redis nosql数据库, osx下使用homebrew安装sidekiq :</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install redis</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后根据提示启动服务, 这里就不说了.</p>
<p>接着, 在rails项目下的Gemfile中加入sidekiq 找个gem, 然后bundle安装:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Gemfile</span><br><span class="line">gem &apos;sidekiq&apos;</span><br><span class="line"></span><br><span class="line">$ bundle install</span><br></pre></td></tr></table></figure>
<h3 id="设定"><a href="#设定" class="headerlink" title="设定"></a>设定</h3><blockquote>
<p>在initializers下新建<code>sidekiq.rb</code>, 作为启动时初始化的设定文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># config/initializers/sidekiq.rb</span><br><span class="line">Sidekiq.configure_server do |config|</span><br><span class="line">  config.redis = &#123; url: &apos;redis://localhost:6379&apos;, namespace: &apos;sidekiq&apos;  &#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="实现worker"><a href="#实现worker" class="headerlink" title="实现worker"></a>实现worker</h3><blockquote>
<p>我们需要新建一个<code>app/workers/event_worker.rb</code> 来处理这些异步任务.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># app/workers/event_worker.rb 名字可以任意, 但是需要include Sidekiq::Worker</span><br><span class="line"></span><br><span class="line">class EventWorker</span><br><span class="line">  include Sidekiq::Worker</span><br><span class="line"></span><br><span class="line">  # 也可以为queue起一个名字, 启动命令也需要指定该名称和优先级</span><br><span class="line">  # sidekiq_options queue: :event</span><br><span class="line">  # bundle execd -q post,5 default</span><br><span class="line">  def perform(id)</span><br><span class="line">    event = Event.find(id)</span><br><span class="line">    event.calculate_rank!</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>真正后台执行的代码应该放到<code>perform</code>方法中, 参数尽量使用id, 而不是对象本身.</p>
</blockquote>
<h3 id="把job放入queue中"><a href="#把job放入queue中" class="headerlink" title="把job放入queue中"></a>把job放入queue中</h3><blockquote>
<p>使用<code>perform_async</code>方法可以把worker扔进queue中, 启动worker就会从redis中把job抓取下来:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># app/controllers/events_controller.rb</span><br><span class="line"></span><br><span class="line">class EventsController</span><br><span class="line">  def ranking</span><br><span class="line">    EventWorker.perform_async @event.id</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>perform_in</code>方法可以让worker过多长时间以后再去执行:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class EventsController</span><br><span class="line">  def ranking</span><br><span class="line">    EventWorker.perform_in 1.hour, @event.id</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="启动sidekiq"><a href="#启动sidekiq" class="headerlink" title="启动sidekiq"></a>启动sidekiq</h3><blockquote>
<p>使用如下命令启动sidekiq</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bundle exec sidekiq -q default event,5</span><br></pre></td></tr></table></figure>
<h3 id="启动设定"><a href="#启动设定" class="headerlink" title="启动设定"></a>启动设定</h3><blockquote>
<p>如果需要指定的参数过多, 那么每一次重启都会很麻烦, 可以写入配置文件中来指定这些参数:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># config/sidekiq.yml</span><br><span class="line">:verbose: false</span><br><span class="line">:pidfile: ./tmp/pids/sidekiq.pid</span><br><span class="line">:logfile: ./log/sidekiq.log</span><br><span class="line">:concurrency:  25</span><br><span class="line">:queues:</span><br><span class="line">  - default</span><br><span class="line">  - event</span><br></pre></td></tr></table></figure>
<blockquote>
<p>启动时直接读取配置文件就可以:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bundle exec sidekiq -C config/sidekiq.yml</span><br></pre></td></tr></table></figure>
<h3 id="和capistrono集成"><a href="#和capistrono集成" class="headerlink" title="和capistrono集成"></a>和capistrono集成</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># config/deploy.rb</span><br><span class="line">set :sidekiq_cmd, &quot;bundle exec sidekiq&quot;</span><br><span class="line">set :sidekiqctl_cmd, &quot;bundle exec sidekiqctl&quot;</span><br><span class="line"></span><br><span class="line">require &apos;sidekiq/capistrano&apos;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">config/sidekiq.yml</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">:verbose: false</span><br><span class="line">:concurrency: 1</span><br><span class="line">staging:</span><br><span class="line">  :concurrency: 1</span><br><span class="line">production:</span><br><span class="line">  :concurrency: 10</span><br><span class="line">  :queues:</span><br><span class="line">    - [default, 1]</span><br><span class="line">    - [mailer, 9]</span><br></pre></td></tr></table></figure>
<h3 id="重试处理"><a href="#重试处理" class="headerlink" title="重试处理"></a>重试处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># app/workers/event_worker.rb</span><br><span class="line">sidekiq_options queue: :event, retry: 5</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不进行重试</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sidekiq_options queue: :event, retry: false</span><br></pre></td></tr></table></figure>
<h3 id="设定web-console"><a href="#设定web-console" class="headerlink" title="设定web console"></a>设定web console</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Gemfile</span><br><span class="line">gem &apos;sinatra&apos;, require: false</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># config/routes.rb</span><br><span class="line">require &apos;sidekiq/web&apos;</span><br><span class="line">[...]</span><br><span class="line">  mount Sidekiq::Web =&gt; &apos;/sidekiq&apos;</span><br></pre></td></tr></table></figure>
<p><img src="http://i3.tietuku.com/e3099bc50724d3ac.png"></p>
<blockquote>
<p>如果想要绑定devise, 请参考 <a href="https://github.com/mperham/sidekiq/wiki/Monitoring" target="_blank" rel="external">https://github.com/mperham/sidekiq/wiki/Monitoring</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># config/routes.rb</span><br><span class="line">authenticate :user, lambda &#123; |u| u.admin?  &#125; do</span><br><span class="line">  mount Sidekiq::Web =&gt; &apos;/sidekiq&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><blockquote>
<p>使用rspec-sidekiq gem测试, 参考 <a href="https://github.com/philostler/rspec-sidekiq" target="_blank" rel="external">https://github.com/philostler/rspec-sidekiq</a></p>
</blockquote>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/03/intro-http-caching-with-rails/" itemprop="url">
                  译 ~ 介绍Rails中的条件HTTP缓存
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-03T13:48:33+08:00" content="2015-04-03">
              2015-04-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Rails/" itemprop="url" rel="index">
                    <span itemprop="name">Rails</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>引自<a href="https://robots.thoughtbot.com/introduction-to-conditional-http-caching-with-rails" target="_blank" rel="external">https://robots.thoughtbot.com/introduction-to-conditional-http-caching-with-rails</a></p>
<p>HTTP提供给开发者了开发者强大的工具来缓存响应. 一般来讲我们不希望客户端盲目缓存已经获取的内容, 也不希望依赖指定的expiration headers. 我们需要一种方法让客户端来问服务器一个资源是否被更新过了.<br>HTTP提供了这种条件性的缓存方法. 客户端可以发送请求给服务器来找出服务器中是不是有一个资源的新版本.<br>Rails又提供了强大的工具来利用这一特点. 接下来看看一些普通的方法检查客户端缓存是新的还是过时的.</p>
</blockquote>
<h2 id="ETags"><a href="#ETags" class="headerlink" title="ETags"></a>ETags</h2><blockquote>
<p>ETags是entity tags的缩写, 是一种普遍的方式来条件下的验证HTTP缓存. ETags是代表所给内容的摘要.服务器返回的响应包含了ETag, 代表资源的状态, 作为HTTP响应头的一部分. 后续的HTTP请求想知道上次请求之后资源是否已经改变, 可以通过发送<code>If-None-Match</code>请求头. 然后服务器会去比较所请求资源的Etag和请求中提供的是否相同, 若相同, 客户端缓存会被认为是新的服务器会返回”304 Not Modified”状态.如果不相同服务器就会响应一个新的Etag和已经更新的资源.</p>
</blockquote>
<h2 id="Last-Modified-Timestamp"><a href="#Last-Modified-Timestamp" class="headerlink" title="Last-Modified Timestamp"></a>Last-Modified Timestamp</h2><blockquote>
<p>另一个服务器提供的header是<code>Last-Modified</code>, 它会返回资源上次被修改的时间.然后客户端会包含<code>If-Modified-Since</code> header 和<code>Last-Modified</code> 时间戳值来询问服务器前一次请求后该资源是否被修改过.<br>同样, 如果上次请求之后资源没有被修改, 服务器就会响应一个”304 Not Modified”状态. 否则它会更新资源和新的<code>Last-Modified</code>时间戳.</p>
</blockquote>
<h2 id="Caching-with-fresh-when"><a href="#Caching-with-fresh-when" class="headerlink" title="Caching with fresh_when"></a>Caching with fresh_when</h2><blockquote>
<p>现在看看Rails对这两个header是如果处理的(<code>ETags and Last-Modified HTTP</code>)<br>ActionController提供了一个强大的方法叫做<code>fresh_when</code>. 它会使用ETag或者Last-Modified时间戳来资源是否是最新的.<br>假设有一个简单的Rails 博客应用:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># app/controllers/posts_controller.rb</span><br><span class="line">class PostsController &lt; ApplicationController</span><br><span class="line">  def show</span><br><span class="line">    @post = Post.find(params[:id])</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># config/routes.rb</span><br><span class="line">Rails.application.routes.draw do</span><br><span class="line">  resources :posts</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果使用curl请求一个单独的post, 应该可以看到这些东西返回:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i http://localhost:3000/posts/1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>返回的内容:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Etag: &quot;4af7e17fc369c6d1af99f8994d8fd387&quot;</span><br><span class="line">Server: WEBrick/1.3.1 (Ruby/2.1.2/2014-05-08)</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Blog post 1&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;lorem ipsum&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意, 现在我们还没做什么特别的事情, 注意一下响应中ETag, 它代表了被返回的资源.<br>如果我继续使用这条curl命令去请求资源发现每一次的ETag都是不同的.那就与刚才的讨论相违背了, 因为资源没有发生变化.<br>我需要修改controller通知它: 从上一次被修改到post没有被修改. 所以再次发生请求, ETag的值是没有改变的:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -i http://localhost:3000/posts/1</span><br><span class="line"></span><br><span class="line"># =&gt;</span><br><span class="line">Content-Length: 667</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Etag: &quot;534279bfc931d4236713095ffd3efb28&quot;</span><br><span class="line">Last-Modified: Wed, 12 Nov 2014 15:44:46 GMT</span><br><span class="line">Server: WEBrick/1.3.1 (Ruby/2.1.3/2014-09-19)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这时发现响应中多了post <code>Last-Modified</code>时间戳. 我们还需要通过ETag或者last modified时间戳(对应的HTTP请求header分别为<code>If-None-Match</code>和<code>If-Modified-Since</code>)验证缓存是否有效:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -i -H &apos;If-None-Match: &quot;534279bfc931d4236713095ffd3efb28&quot;&apos; http://localhost:3000/posts/1</span><br><span class="line"></span><br><span class="line"># =&gt;</span><br><span class="line">HTTP/1.1 304 Not Modified</span><br><span class="line">Etag: &quot;534279bfc931d4236713095ffd3efb28&quot;</span><br><span class="line">Last-Modified: Wed, 12 Nov 2014 15:44:46 GMT</span><br><span class="line">Server: WEBrick/1.3.1 (Ruby/2.1.3/2014-09-19)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果是<code>If-Modified-Since</code>header:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -i -H &apos;If-Modified-Since: Wed, 12 Nov 2014 15:44:46 GMT&apos; http://localhost:3000/posts/1</span><br><span class="line"></span><br><span class="line"># =&gt;</span><br><span class="line">HTTP/1.1 304 Not Modified</span><br><span class="line">Etag: &quot;534279bfc931d4236713095ffd3efb28&quot;</span><br><span class="line">Last-Modified: Wed, 12 Nov 2014 15:44:46 GMT</span><br><span class="line">Server: WEBrick/1.3.1 (Ruby/2.1.3/2014-09-19)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当然上面两种方式的结果是一样的.</p>
</blockquote>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><blockquote>
<p>为了弄清楚缓存到底为我们带来了什么, 先看看在没有使用cache的情况下Rails的日志:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Started GET &quot;/posts/1&quot; for 127.0.0.1 at 2014-11-12 11:33:57 -0500</span><br><span class="line">Processing by PostsController#show as */*</span><br><span class="line">Parameters: &#123;&quot;id&quot;=&gt;&quot;1&quot;&#125;</span><br><span class="line">Post Load (0.3ms)  SELECT  &quot;posts&quot;.* FROM &quot;posts&quot;  WHERE &quot;posts&quot;.&quot;id&quot; = $1</span><br><span class="line">LIMIT 1  [[&quot;id&quot;, 1]]</span><br><span class="line">Rendered posts/show.html.erb within layouts/application (0.1ms)</span><br><span class="line">Rendered application/_flashes.html.erb (0.0ms)</span><br><span class="line">Rendered application/_analytics.html.erb (0.1ms)</span><br><span class="line">Rendered application/_javascript.html.erb (16.1ms)</span><br><span class="line">Completed 200 OK in 35ms (Views: 33.4ms | ActiveRecord: 0.3ms)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们发现请求耗费了33ms, render了很多模板以及局部文件. 不难发现, 多数时间耗费在了render处理.而ActiveRecord花费的时间还不足1ms.<br>下面再来看看替换成条件性缓存的日志, 使用<code>If-None-Match</code> :</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Started GET &quot;/posts/1&quot; for 127.0.0.1 at 2014-11-12 11:39:52 -0500</span><br><span class="line">Processing by PostsController#show as */*</span><br><span class="line">Parameters: &#123;&quot;id&quot;=&gt;&quot;1&quot;&#125;</span><br><span class="line">Post Load (0.3ms)  SELECT  &quot;posts&quot;.* FROM &quot;posts&quot;  WHERE &quot;posts&quot;.&quot;id&quot; = $1</span><br><span class="line">LIMIT 1  [[&quot;id&quot;, 1]]</span><br><span class="line">Completed 304 Not Modified in 2ms (ActiveRecord: 0.3ms)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意我已经砍掉了request中的整个render处理. 既然客户端已经缓存了最新响应内容, Rails就没有必要再去render处理. 它可以通过ActiveRecord来载入post, 并且验证自从上一次请求之后是否有被修改过.<br>我们的请求从33ms减少到了2ms. 这在性能上是94%的提高. 不只是跳过了render处理, 我们的响应由于不需要返回body变得更加轻量级了.<br>例子中的数据很小, 如果是在一个背后有许多复杂的逻辑的大的项目中, 那么就会节省很多时间.<br>此外, 这些请求还可以被放到公共的缓存如: “Rack::Cache”中, 来为普通的资源提供共享. 与此相对的就是用户浏览器中的私有缓存.</p>
</blockquote>
<h2 id="Getting-more"><a href="#Getting-more" class="headerlink" title="Getting more"></a>Getting more</h2><blockquote>
<p>单单一个<code>fresh_when</code>方法也不是没有局限性, 它不能处理用户指定的内容. 如果我们想展示每个用户上的不同内容, 是办不到的.<br>另外, 这种缓存是不被用户们共享的, 只有当用户反复去访问同一篇post时这种缓存才能发挥作用.<br>最后, 目前我只是局限于<code>render</code>调用, 如果需要定制化别的格式<code>render xml:</code> 或者<code>render json:</code>又该如何提高访问效率呢? 请参见(<a href="https://robots.thoughtbot.com/how-to-evaluate-your-rails-json-api-for-performance-improvements" target="_blank" rel="external">https://robots.thoughtbot.com/how-to-evaluate-your-rails-json-api-for-performance-improvements</a>) (p.s.我以后会找个时间翻译)</p>
</blockquote>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/01/elastic-search/" itemprop="url">
                  Rails中Elasticsearch + tire 进行全文检索
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-01T11:30:53+08:00" content="2015-04-01">
              2015-04-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Rails/" itemprop="url" rel="index">
                    <span itemprop="name">Rails</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="安装Elasticsearch"><a href="#安装Elasticsearch" class="headerlink" title="安装Elasticsearch"></a>安装Elasticsearch</h2><blockquote>
<p>使用homebrew在Mac下安装:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install elasticsearch</span><br></pre></td></tr></table></figure>
<h2 id="安装tire-gem"><a href="#安装tire-gem" class="headerlink" title="安装tire gem"></a>安装tire gem</h2><blockquote>
<p>tire是一个ruby的包装库, 避免你直接去使用json和Elasticsearch交互</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Gemfile</span><br><span class="line">gem &apos;tire&apos;</span><br></pre></td></tr></table></figure>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><blockquote>
<p>为了可以在model中使用tire, 需要在model中包含tire提供的方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># app/models/article.rb</span><br><span class="line">class Article &lt; ActiveRecord::Base</span><br><span class="line">  belongs_to :auther</span><br><span class="line">  has_many :comments</span><br><span class="line"></span><br><span class="line">  include Tire::Model::Search</span><br><span class="line">  include Tire::Model::Callbacks</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在页面上添加搜索form :</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># app/views/articles/index.html.erb</span><br><span class="line"></span><br><span class="line">&lt;%= form_tag articles_path, method: :get do %&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;%= text_field_tag :query, params[:query] %&gt;</span><br><span class="line">    &lt;%= submit_tag &quot;Search&quot;, name: nil %&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;% end %&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接下来只需要在<code>index</code>action中通过调单传过来的值调用Tire提供的<code>search</code>方法即可:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># app/controllers/articles_controller.rb</span><br><span class="line"></span><br><span class="line">def index</span><br><span class="line">  if params[:query].persent?</span><br><span class="line">    @articles = Article.search(params[:query], load: true)</span><br><span class="line">  else</span><br><span class="line">    @articles = Article.all</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>load: true</code>这个选项需要指定的原因是: 如果不指定该选项, 当我在搜索时, Tire会试图最小化访问数据库, 它不会去从数据库中拿关联的对象.</p>
<p>还可以在model中定制化<code>search</code>方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># articles.rb</span><br><span class="line">def self.search(params) </span><br><span class="line">  tire.search(load: true) do</span><br><span class="line">    query &#123;string params[:query]&#125; if params[:query].present?</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># articles_controller.rb</span><br><span class="line">def index</span><br><span class="line">    @articles = Article.search(params)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="使用will-paginate分页"><a href="#使用will-paginate分页" class="headerlink" title="使用will_paginate分页"></a>使用<code>will_paginate</code>分页</h2><blockquote>
<p>分页的实现只需要在model的search方法做就可以了:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># articles.rb</span><br><span class="line">def self.search(params) </span><br><span class="line">  tire.search(load: true, page: params[:page], per_page: 2) do</span><br><span class="line">    query &#123;string params[:query]&#125; if params[:query].present?</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># index.html.erb</span><br><span class="line">[...]</span><br><span class="line">&lt;%= will_paginate %&gt;</span><br></pre></td></tr></table></figure>
<h2 id="使用关联model的属性搜索"><a href="#使用关联model的属性搜索" class="headerlink" title="使用关联model的属性搜索"></a>使用关联model的属性搜索</h2><blockquote>
<p>如果需要使用相关联的model的属性作为关键词, 那么就需要重写<code>to_indexed_json</code>方法 :</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># article.rb</span><br><span class="line"></span><br><span class="line">def to_indexed_json</span><br><span class="line">  to_json(methods: [:auther_name])</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def auther_name</span><br><span class="line">  auther.name</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后重新索引Article 数据:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rake environment tire:import CLASS=Article FORCE=true</span><br></pre></td></tr></table></figure>
<h2 id="替换掉load-true"><a href="#替换掉load-true" class="headerlink" title="替换掉load: true"></a>替换掉<code>load: true</code></h2><blockquote>
<p>如果每次使用<code>load: true</code>来加载相关对象, 就增大了数据库的访问量, 影响效率, 可以利用上面的<code>to_json</code>方法, 先计算出对象的属性值, 加入到索引中:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># article.rb</span><br><span class="line"></span><br><span class="line">def to_indexed_json</span><br><span class="line">  to_json(methods: [:auther_name])</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def auther_name</span><br><span class="line">  auther.name</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># index.html.erb</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line">&lt;td&gt;&lt;%= article.auther_name %&gt;&lt;/td&gt;</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样处理, 以后每次刷新就不会再去访问数据库了.</p>
</blockquote>
<h2 id="facet-过滤"><a href="#facet-过滤" class="headerlink" title="facet 过滤"></a>facet 过滤</h2><blockquote>
<p>实现过滤效果: </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># article.rb</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line">facet &apos;authers&apos; do</span><br><span class="line">  terms :auther_id</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># index.html.erb</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;Authers&lt;/h3&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;% @articles.facets[&apos;authers&apos;][&apos;terms&apos;].each do |facet| %&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;%= link_to_unless_current Auther.find(facet[&apos;term&apos;]).name, params.merge(auther_id: facet[&apos;term&apos;]) %&gt;</span><br><span class="line">&lt;% if params[:auther_id] == facet[&apos;term&apos;].to_s %&gt;</span><br><span class="line">(&lt;%= link_to &quot;remove&quot;, auther_id: nil %&gt;)</span><br><span class="line">&lt;% else %&gt;</span><br><span class="line">(&lt;%= facet[&apos;count&apos;] %&gt;)</span><br><span class="line">&lt;% end %&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;% end %&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p><img src="http://i2.tietuku.com/e01fb5992501593a.png"></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/31/rails-cancan-login/" itemprop="url">
                  Rails4 + devise + rails_admin + cancancan实现权限管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-31T19:33:43+08:00" content="2015-03-31">
              2015-03-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Rails/" itemprop="url" rel="index">
                    <span itemprop="name">Rails</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="安装gem"><a href="#安装gem" class="headerlink" title="安装gem"></a>安装gem</h2><blockquote>
<p>创建好项目后安装gem:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gem &apos;devise&apos;</span><br><span class="line">gem &apos;cancancan&apos;</span><br><span class="line">gem &apos;rails_admin&apos;</span><br><span class="line"></span><br><span class="line">$ bundle</span><br></pre></td></tr></table></figure>
<h2 id="设定devise"><a href="#设定devise" class="headerlink" title="设定devise"></a>设定devise</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rails g devise:install</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># config/environments/development.rb</span><br><span class="line">config.action_mailer.default_url_options = &#123; :host =&gt; &apos;localhost:3000&apos;  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># app/views/layouts/application.html.erb</span><br><span class="line">&lt;% if notice %&gt;</span><br><span class="line">  &lt;p class=&quot;alert alert-notice&quot;&gt;&lt;%= notice %&gt;&lt;/p&gt;</span><br><span class="line">&lt;% end %&gt;</span><br><span class="line"></span><br><span class="line">% if alert %&gt;</span><br><span class="line">    &lt;p class=&quot;alert alert-error&quot;&gt;&lt;%= alert %&gt;&lt;/p&gt;</span><br><span class="line">&lt;% end %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%= yield %&gt;</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用devise创建user model, 在创建一个role model, 作为角色, 然后将两者连接起来:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rails g devise:user</span><br><span class="line">rails g model role</span><br><span class="line">rails g migration CreateJoinTableUserRole user role</span><br><span class="line">rake db:migrate</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编辑model :</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># app/models/user.rb</span><br><span class="line">has_many_and_belongs_to :roles</span><br><span class="line"></span><br><span class="line">def has_role?(name)</span><br><span class="line">  self.roles.where(name: name).length &gt; 0</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># app/models/role.rb</span><br><span class="line"></span><br><span class="line">has_many_and_belongs_to :users</span><br></pre></td></tr></table></figure>
<h2 id="设置cancancan"><a href="#设置cancancan" class="headerlink" title="设置cancancan"></a>设置cancancan</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># app/models/ability.rb</span><br><span class="line">if user.has_role?(&apos;admin&apos;)</span><br><span class="line">  can :read, :all</span><br><span class="line">  can :access, :rails_admin</span><br><span class="line">  can :dashboard</span><br><span class="line">  if user.has_role?(&apos;superadmin&apos;)</span><br><span class="line">    can :manage, :all</span><br><span class="line">  else</span><br><span class="line">    can :manage, [] # A</span><br><span class="line">  end</span><br><span class="line">else</span><br><span class="line">  can :read, [] # B</span><br><span class="line">  can :create, [] # C</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>superadmin可以管理所有的model, admin用户可以读取所有的model, 数组可以指定model, 表示可以对这些model操作.</p>
</blockquote>
<h2 id="设置rails-admin"><a href="#设置rails-admin" class="headerlink" title="设置rails_admin"></a>设置rails_admin</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rails g rails_admin:install</span><br><span class="line">rake db:migrate</span><br></pre></td></tr></table></figure>
<blockquote>
<p>添加<code>Devise</code>和 <code>Cancan</code>配置:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># == Devise ==</span><br><span class="line">config.authenticate_with do</span><br><span class="line">warden.authenticate! scope: :user</span><br><span class="line">end</span><br><span class="line">config.current_user_method(&amp;:current_user)</span><br><span class="line"></span><br><span class="line"># == Cancan ==</span><br><span class="line">config.authorize_with :cancan</span><br></pre></td></tr></table></figure>
<blockquote>
<p>启动rails 服务器:</p>
</blockquote>
<p><img src="http://i3.tietuku.com/1ca38e0cbcf6bddd.png"><br><img src="http://i3.tietuku.com/bb08a45afb8c0d47.png"></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/31/design-active-record/" itemprop="url">
                  Active Record 的设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-31T09:27:29+08:00" content="2015-03-31">
              2015-03-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Rails/" itemprop="url" rel="index">
                    <span itemprop="name">Rails</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Active Record可以让你在Rails中把Ruby对象映射到数据库记录.这种功能叫做”对象关系映射”.它可以帮你得到持久化层和逻辑层的关系. 本篇研究一下它是如何映射的.</p>
</blockquote>
<h2 id="A-Short-Active-Record-Example-一个简短的Active-Record例子"><a href="#A-Short-Active-Record-Example-一个简短的Active-Record例子" class="headerlink" title="A Short Active Record Example (一个简短的Active Record例子)"></a>A Short Active Record Example (一个简短的Active Record例子)</h2><blockquote>
<p>假设有一个基于文件的SQLite 数据库, 它遵守Active Record的约定: 假设, 数据库包含一个表叫做<code>ducks</code>, 有一个字段为<code>name</code>. 你想把ducks的记录映射到class Duck的对象上.<br>首先需要引入’active_record’, 然后利用它建立到数据库的链接:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require &apos;active_record&apos;</span><br><span class="line"></span><br><span class="line">ActiveRecord::Base.establish_connnection :adapter =&gt; &quot;sqlite3&quot;, :database =&gt; &quot;dbfile&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ActiveRecord::Base 是 Active Record, 不仅可以建立连接, 它也是所有被映射的类的超类:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Duck &lt; ActiveRecord::Base</span><br><span class="line">  validate do</span><br><span class="line">    errors.add(:base, &quot;Illegal duck name.&quot;) unless name[0] == &apos;D&apos;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>validate</code>是一个 Class Macro, 接受block作为参数, 确保Duck的name应该以D开头. 根据约定, Active Record自动把Duck对象匹配给ducks数据库表, Active Record通过database schema(db/schema.rb)找到Duck有一个name的字段, 它会定义一个Ghost 方法来访问该字段, 就是由于有这些约定, 你可以马上使用Duck类:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_duck = Duck.new</span><br><span class="line">my_duck.name = &quot;Donald&quot;</span><br><span class="line">my_duck.valid? # =&gt; true</span><br><span class="line">my_duck.save!</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从数据库读取:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">duck_from_database = Duck.first</span><br><span class="line">duck_from_database.name # =&gt; &quot;Donald&quot;</span><br><span class="line">duck_from_database.delete</span><br></pre></td></tr></table></figure>
<h3 id="How-Active-Record-Is-Put-Together-AR-是如何被放到一起的"><a href="#How-Active-Record-Is-Put-Together-AR-是如何被放到一起的" class="headerlink" title="How Active Record Is Put Together(AR 是如何被放到一起的?)"></a>How Active Record Is Put Together(AR 是如何被放到一起的?)</h3><blockquote>
<p>事实上, ActiveRecord有很多功能, 比如save, validate这些方法等等, 但是打开源码发现并没有发现这些方法的定义.</p>
</blockquote>
<h3 id="The-Autoloading-Mechanism-自动加载机制"><a href="#The-Autoloading-Mechanism-自动加载机制" class="headerlink" title="The Autoloading Mechanism(自动加载机制)"></a>The Autoloading Mechanism(自动加载机制)</h3><blockquote>
<p>当<code>require active_record</code>时, 看下面的源码:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">require &apos;active_support&apos; </span><br><span class="line">require &apos;active_model&apos;</span><br><span class="line"># ...</span><br><span class="line"></span><br><span class="line">module ActiveRecord</span><br><span class="line">  extend ActiveSupport::Autoload</span><br><span class="line">  autoload :Base </span><br><span class="line">  autoload :NoTouching </span><br><span class="line">  autoload :Persistence </span><br><span class="line">  autoload :QueryCache </span><br><span class="line">  autoload :Querying </span><br><span class="line">  autoload :Validations </span><br><span class="line">  # ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>active_record</code>去依赖另外两个库:Active Support 和 Active Model. ActiveSupport::Autoload module定义了<code>autoload</code>方法, 这个方法可以帮我们找到并且载入我们所使用的module.</p>
</blockquote>
<h3 id="ActiveRecord-Base"><a href="#ActiveRecord-Base" class="headerlink" title="ActiveRecord::Base"></a>ActiveRecord::Base</h3><blockquote>
<p>这里有一个至关重要的类: ActiveRecord::Base :</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module ActiveRecord</span><br><span class="line">  class Base</span><br><span class="line">    extend ActiveModel::Naming</span><br><span class="line">    extend ActiveSupport::Benchmarkable</span><br><span class="line">    [...]</span><br><span class="line">    include Core</span><br><span class="line">    include Persistence</span><br><span class="line">    [...]</span><br><span class="line">  end</span><br><span class="line">  ActiveSupport.run_load_hooks(:active_record, Base)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/30/ruby-metaprogramming-chpt6-code-that-write-code/" itemprop="url">
                  Ruby 元编程 第六章 Code That Writes Code
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-30T13:32:07+08:00" content="2015-03-30">
              2015-03-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Ruby/" itemprop="url" rel="index">
                    <span itemprop="name">Ruby</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Kernel-eval"><a href="#Kernel-eval" class="headerlink" title="Kernel#eval"></a>Kernel#eval</h2><blockquote>
<p>之前学习过<code>class_eval</code>和<code>instance_eval</code>, 还有一个比较直接的方法<code>Kernel#eval</code>, 它不像前两者计算的是block, 它会把字符串作为Ruby代码来运行:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array = [10, 20]</span><br><span class="line">element = 30</span><br><span class="line">eval(&quot; array &lt;&lt; element&quot;) # =&gt; # =&gt; [10, 20, 30]</span><br></pre></td></tr></table></figure>
<h3 id="Binding-Objects-绑定对象"><a href="#Binding-Objects-绑定对象" class="headerlink" title="Binding Objects (绑定对象)"></a>Binding Objects (绑定对象)</h3><blockquote>
<p>Binding 将整个scope打包成对象, 通过创建Binding来捕捉当前的scope, 以后可以通过与<code>eval</code>配合执行该scope中的代码:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line">  def my_method</span><br><span class="line">    @x = 1</span><br><span class="line">    binding</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">b = MyClass.new.my_method</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以把绑定对象理解成闭包对象, 然后可以计算b这个scope中@x的值:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval &quot;@x&quot;, b #=&gt; 1</span><br></pre></td></tr></table></figure>
<h3 id="Strings-of-Code-vs-Blocks"><a href="#Strings-of-Code-vs-Blocks" class="headerlink" title="Strings of Code vs. Blocks"></a>Strings of Code vs. Blocks</h3><blockquote>
<p>事实上<code>instance_eval</code>和<code>class_eval</code>也可以运行字符串:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">x = &apos;d&apos;</span><br><span class="line">array.instance_eval &quot;self[1] = x&quot;</span><br><span class="line">array # =&gt; [&quot;a&quot;, &quot;d&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>那么到底是使用String还是block?</p>
</blockquote>
<h3 id="The-Trouble-with-eval"><a href="#The-Trouble-with-eval" class="headerlink" title="The Trouble with eval()"></a>The Trouble with eval()</h3><blockquote>
<p>String的代码确实很强大, 但是也会出现一些问题, 比如说编辑器不会为这样的代码高亮显示, 可读性差.</p>
</blockquote>
<h2 id="Hook-Methods"><a href="#Hook-Methods" class="headerlink" title="Hook Methods"></a>Hook Methods</h2><blockquote>
<p>这里介绍一个方法<code>Class#inherited</code>, <code>inherited</code>是Class的一个实例方法, 当一个class被继承Ruby就会调用它, 像这样的方法被称作<code>Hook Method</code> 因为你可以用它来勾住指定的事件. 个人觉得可以这样记忆该方法: “当我被继承了之后执行这个方法”.<br>类似的, 我们还可以重写针对Module的<code>Module#included</code> 和 “Module#prepended”</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module M1</span><br><span class="line">  def self.included(othermod)</span><br><span class="line">    puts &quot;M1 was included into #&#123;othermod&#125;&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">module M2</span><br><span class="line">  def self.prepended(othermod)</span><br><span class="line">    puts &quot;M2 was prepended to #&#123;othermod&#125;&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line">class C</span><br><span class="line">  include M1 </span><br><span class="line">  prepend M2</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">M1 was included into C</span><br><span class="line">M2 was prepended to C</span><br></pre></td></tr></table></figure>
<blockquote>
<p>相应的, 还有<code>method_added</code>, <code>method_removed</code>, 和<code>method_undefined</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">module M</span><br><span class="line">  def self.method_added(method)</span><br><span class="line">    puts &quot;New method: M##&#123;method&#125;&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def my_method</span><br><span class="line">    </span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def self.method_undefined(method)</span><br><span class="line">    puts &quot;Undefine method: M##&#123;method&#125;&quot;</span><br><span class="line">  end</span><br><span class="line">  undef :my_method</span><br><span class="line"></span><br><span class="line">  def self.method_removed(method)</span><br><span class="line">    puts &quot;Remove method: M## &#123;method&#125;&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def print</span><br><span class="line">    </span><br><span class="line">  end</span><br><span class="line">  remove_method :print</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上只是针对普通方法而已, 如果是singleton_method, 也有需要的hook方法: <code>BasicObject#sin- gleton_method_added, singleton_method_removed, and singleton_method_undefined</code></p>
</blockquote>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/29/ruby-metaprogramming-chpt5-class-definitions/" itemprop="url">
                  Ruby 元编程 第五章 Class Definitions
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-29T08:31:02+08:00" content="2015-03-29">
              2015-03-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Ruby/" itemprop="url" rel="index">
                    <span itemprop="name">Ruby</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Class-Definitions-Demystified-解开类定义的神秘"><a href="#Class-Definitions-Demystified-解开类定义的神秘" class="headerlink" title="Class Definitions Demystified(解开类定义的神秘)"></a>Class Definitions Demystified(解开类定义的神秘)</h2><h3 id="Inside-Class-Definitions"><a href="#Inside-Class-Definitions" class="headerlink" title="Inside Class Definitions"></a>Inside Class Definitions</h3><blockquote>
<p>不同于Java的类, 我们不仅可以在Ruby的类中定义方法, 还可以任何东西:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line">  puts &quot;Hello&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>类定义还可以返回值:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = class MyClass</span><br><span class="line">  self</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">result #=&gt; MyClass</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个例子说明了, 在class或者module的定义中, class自己承担当前对象self的角色.</p>
</blockquote>
<h3 id="The-Current-Class"><a href="#The-Current-Class" class="headerlink" title="The Current Class"></a>The Current Class</h3><blockquote>
<p>无论你在Ruby程序的哪个位置, 你总会有当前class或者module, 在class中定义的方法就是当前class的实例方法.<br>在程序中如何确定当前class:</p>
</blockquote>
<ul>
<li>在程序顶层, 当前class是<code>Object</code>, main的class, 联想一下irb.如果你在程序的顶层定义一个方法, 这个方法就是Object的实例方法</li>
<li>在一个方法中, 当前class就是当前对象的class</li>
<li>使用<code>class</code>关键字打开一个类, 那个class就变成了当前class.</li>
</ul>
<blockquote>
<p>有些情况下, 我不知道一个类的名字, 如何在里面加入一个方法呢?</p>
</blockquote>
<h4 id="class-eval"><a href="#class-eval" class="headerlink" title="class_eval()"></a>class_eval()</h4><blockquote>
<p><code>class_eval</code>方法可以帮助我, 在未知类名的情况下, 为这个类添加方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def add_method_to(a_class)</span><br><span class="line">  a_class.class_eval do</span><br><span class="line">    def m; puts &quot;#&#123;self&#125; hello&quot;; end</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">add_method_to String</span><br><span class="line">&quot;abd&quot;.m   #=&gt; abd hello</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>class_eval</code>在当前class环境中计算block的值. <code>class_eval</code>修改当前类和self(当前对象, 例如上面”abd”), <code>instance_eval</code>修改当前对象(self)</p>
<p>可以看出<code>class_eval</code>要比使用<code>class</code>关键字打开类更加灵活, 它可以使用变量引用一个类, <code>class</code>关键字.另外, <code>class</code>关键字打开了一个新的scope, 丢失了当前的绑定, 而<code>class_eval</code>可以把外界scope的变量引入.<br>最后, <code>class_eval</code>也有一个类似方法可以把额外参数传入到block中.<br>多数情况下, 使用<code>instance_eval</code>打开一个对象(非class), <code>class_eval</code>打开一个类的定义, 然后使用<code>def</code>在里面定义方法.</p>
</blockquote>
<h3 id="Current-Class-Wrap-up"><a href="#Current-Class-Wrap-up" class="headerlink" title="Current Class Wrap-up"></a>Current Class Wrap-up</h3><blockquote>
<p>关键点回顾:</p>
</blockquote>
<ul>
<li>Ruby解释器一直在引用这当前的class. 使用<code>def</code>定义的方法就是当前class的实例方法.</li>
<li>在class定义中, 当前object和当前class是一个东西, 被定义的类</li>
<li>如果你有一个class的引用, 你就可以使用<code>class_eval</code>(或者module_eval)打开这个类.</li>
</ul>
<h3 id="Class-Instance-Variables"><a href="#Class-Instance-Variables" class="headerlink" title="Class Instance Variables"></a>Class Instance Variables</h3><blockquote>
<p>Ruby解释器认为所有的变量属于当前对象self, 对于类定义来说也是这样. 类的实例变量和类对象的实例变量是不同的:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line">  @my_var = 1    # 类的实例变量</span><br><span class="line">  def self.read; @my_var; end</span><br><span class="line">  def write; @my_var = 2; end    # 类的对象的实例变量</span><br><span class="line">  def read; @my_var; end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">obj = MyClass.new</span><br><span class="line">obj.read       # =&gt; nil</span><br><span class="line">obj.write</span><br><span class="line">obj.read       # =&gt; 2</span><br><span class="line"></span><br><span class="line">MyClass.read   # =&gt; 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Class Instance Variables 实际上属于<code>Class</code>的对象, 正是因为这样, 它只能被class本身访问, 不能被子类访问, 因为即使是子类, 也是不同的<code>Class</code>对象.</p>
<p>例子中@my_var是不同的, 类实例变量的是<code>MyClass</code>作为self, 而对象实例变量是以<code>obj</code>作为self.</p>
</blockquote>
<h3 id="Class-Variables"><a href="#Class-Variables" class="headerlink" title="Class Variables"></a>Class Variables</h3><blockquote>
<p>还有一种存储变量的方法是使用Class Variables, 使用2个<code>@</code>定义如<code>@@var</code>, 与Class Instance Variables不同的是, 它可以被子类或者实例方法访问到, 这一点和Java静态成员变量相似:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class C</span><br><span class="line">  @@v = 10</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">class D &lt; C</span><br><span class="line">  def my_method; @@v += 1; end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puts D.new.my_method # =&gt; 11</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是它有一个非常不好的特点:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@@v = 1</span><br><span class="line">class MyClass</span><br><span class="line">  @@v = 2</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">@@v  #=&gt; 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>class variable不属于类, 它属于类继承关系, @@v被定义与main中, 它属于main的class— Object, MyClass又是Object的子类, 这样就造成了麻烦, 所以还是尽量避免使用class variable.</p>
</blockquote>
<h2 id="Singleton-Methods-单例方法"><a href="#Singleton-Methods-单例方法" class="headerlink" title="Singleton Methods (单例方法)"></a>Singleton Methods (单例方法)</h2><h3 id="Introducing-Singleton-Methods"><a href="#Introducing-Singleton-Methods" class="headerlink" title="Introducing Singleton Methods"></a>Introducing Singleton Methods</h3><blockquote>
<p>Ruby允许给某个对象单独添加方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;just a regular string&quot;</span><br><span class="line">def str.title?</span><br><span class="line">  self.upcase == self</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">str.title? # =&gt; false</span><br><span class="line">str.methods.grep(/title?/) # =&gt; [:title?]</span><br><span class="line">str.singleton_methods # =&gt; [:title?]</span><br></pre></td></tr></table></figure>
<h3 id="Duck-Typing"><a href="#Duck-Typing" class="headerlink" title="Duck Typing"></a>Duck Typing</h3><blockquote>
<p>在Ruby这样的动态语言中, 一个对象的类型并不是严格和它的类关联的, 类型只不过是一些方法的集合, 对象可以响应, 这种更加灵活的对类型的定义被称作<code>duck typing</code>, 如果一个东西走起来叫起来像鸭子, 那么它就是鸭子.换言之, 你不必担心一个对象是不是class Duck的实例, 你只需要关心它是否可以响应<code>walk</code>和<code>quack</code>方法, 至于该方法是正常的方法, 还是单例方法, 还是Ghost 方法都无所谓.</p>
</blockquote>
<h3 id="The-Truth-About-Class-Methods-类方法的真正含义"><a href="#The-Truth-About-Class-Methods-类方法的真正含义" class="headerlink" title="The Truth About Class Methods (类方法的真正含义)"></a>The Truth About Class Methods (类方法的真正含义)</h3><blockquote>
<p>由于类是对象, 类名是常量, 所以在对象上调用一个方法相当于在类上调用一个方法.:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">an_object.a_method</span><br><span class="line">AClass.a_class_method</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所以我们一直使用的是一个类的单例方法, 看这两个方法定义:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def obj.singleton_method; end</span><br><span class="line">def MyClass.singleton_method; end</span><br><span class="line">def self.singleton_method; end</span><br></pre></td></tr></table></figure>
<h3 id="Class-Macros-类宏"><a href="#Class-Macros-类宏" class="headerlink" title="Class Macros (类宏)"></a>Class Macros (类宏)</h3><h4 id="The-attr-accessor-Example"><a href="#The-attr-accessor-Example" class="headerlink" title="The attr_accessor() Example"></a>The attr_accessor() Example</h4><blockquote>
<p>Ruby对象是没有属性的, 但是可以模拟属性: 通过两个方法, reader和writer</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line">  def my_attribute=(value)</span><br><span class="line">    @my_attribute = value</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def my_attribute</span><br><span class="line">    @my_attribute</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">obj = MyClass.new</span><br><span class="line">obj.my_attribute = &apos;x&apos;</span><br><span class="line">obj.my_attribute # =&gt; &quot;x&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样写没有问题就是太麻烦, Ruby提供了方法可以快捷生成这些方法, <code>Module#attr_reader</code>, <code>Module#attr_writer</code>和<code>Module#attr_accessor</code>, 分别可以产生reader, writer, reader+writer, 上面的代码可以替换为下面的:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line">  attr_accessor :my_attribute</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="Class-Macros-Applied"><a href="#Class-Macros-Applied" class="headerlink" title="Class Macros Applied"></a>Class Macros Applied</h4><blockquote>
<p>我们可以利用 Class Macros来修改一些方法命名, 而不影响调用者. 比如现有<code>GetTitle</code>, <code>title2</code>和 <code>LEND_TO_USER</code> 这些方法, 但是名字不规范, 需要替换掉, 但是又不能影响其他调用者:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Book</span><br><span class="line">  def title</span><br><span class="line">    puts &quot;Title&quot;</span><br><span class="line">  end</span><br><span class="line">  </span><br><span class="line">  def subtitle</span><br><span class="line">    puts &quot;Subtitle&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def lend_to(user)</span><br><span class="line">    puts &quot;Lending to #&#123;user&#125;&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def self.deprecate(old_method, new_method)</span><br><span class="line">    define_method(old_method) do |*args, &amp;block|</span><br><span class="line">      warn &quot;Warning: #&#123;old_method&#125;() is deprecated. Use #&#123;new_method&#125;().&quot;</span><br><span class="line">      send new_method, *args, &amp;block</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  deprecate :GetTitle, :title</span><br><span class="line">  deprecate :title2, :subtitle</span><br><span class="line">  deprecate :LEND_TO_USER, :lend_to</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b = Book.new</span><br><span class="line">b.LEND_TO_USER(&quot;Bill&quot;)</span><br><span class="line">Warning: LEND_TO_USER() is deprecated. Use lend_to(). </span><br><span class="line">Lending to Bill</span><br></pre></td></tr></table></figure>
<h2 id="Singleton-Classes-单例类"><a href="#Singleton-Classes-单例类" class="headerlink" title="Singleton Classes (单例类)"></a>Singleton Classes (单例类)</h2><h3 id="The-Mystery-of-Singleton-Methods"><a href="#The-Mystery-of-Singleton-Methods" class="headerlink" title="The Mystery of Singleton Methods"></a>The Mystery of Singleton Methods</h3><blockquote>
<p>刚刚已经学习了单例方法, 那么这个方法在哪里保存的呢? 首先, 它不在对象中, 方法都在被存放在类中的, 但是我发现它也没有在对象所属的类中, 那么但类方法到底在哪里?</p>
</blockquote>
<h3 id="Singleton-Classes-Revealed"><a href="#Singleton-Classes-Revealed" class="headerlink" title="Singleton Classes Revealed"></a>Singleton Classes Revealed</h3><blockquote>
<p>一个对象还有自己的特别的隐藏class, 叫做<code>singleton class</code>. 而对象的单例方法就被存在这里了.举个最简单的例子, <code>Object#class</code>方法就是就被定义到它的singleton class中了.<br>下面两种定义singleton method的方法是等价的:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj = Object.new</span><br><span class="line">def obj.say_hello</span><br><span class="line">  puts &quot;hello&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>方法二:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class &lt;&lt; obj</span><br><span class="line">  def say_hello</span><br><span class="line">    puts &quot;hello&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我可以通过<code>singleton_class</code>方法来获取一个对象的singleton class:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;abc&quot;.singleton_class  # =&gt; #&lt;Class:#&lt;String:0x007fb2e32f11e0&gt;&gt;</span><br><span class="line"></span><br><span class="line">等价于:</span><br><span class="line"></span><br><span class="line">class &lt;&lt; &quot;abc&quot;</span><br><span class="line">  self</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>singleton class也是class, 但是比较特殊. 除非你调用<code>Object#singleton_class</code>或者使用<code>class &lt;&lt; syntax</code>来获取这个类. 另外,  singleton classes只有一个实例, 而且不可以被继承. <strong><em>一个singleton class就是对象的单例所存储的地方</em></strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def obj.my_singleton_method; end</span><br><span class="line">singleton_class.instance_methods.grep(/my_/) # =&gt; [:my_singleton_method]</span><br></pre></td></tr></table></figure>
<h3 id="Method-Lookup-Revisited"><a href="#Method-Lookup-Revisited" class="headerlink" title="Method Lookup Revisited"></a>Method Lookup Revisited</h3><h4 id="Singleton-Classes-and-Method-Lookup-单例类和方法的查找"><a href="#Singleton-Classes-and-Method-Lookup-单例类和方法的查找" class="headerlink" title="Singleton Classes and Method Lookup (单例类和方法的查找)"></a>Singleton Classes and Method Lookup (单例类和方法的查找)</h4><blockquote>
<p>之前的方法查找在学习了Singleton class后就有些不准确了:<br>现在定义如下的类:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class C</span><br><span class="line">  def a_method</span><br><span class="line">    &apos;C#a_method()&apos;</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">class D &lt; C; end</span><br><span class="line"></span><br><span class="line">obj = D.new</span><br><span class="line"></span><br><span class="line">obj.singleton_class.superclass # =&gt; D</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在的方法查找过程需要增加一个一个对象的singleton class, 然后才是其所属的类:</p>
</blockquote>
<p><img src="http://i3.tietuku.com/c30f1a17e6aff01b.png"></p>
<h3 id="Singleton-Classes-and-Inheritance-单例类的继承关系"><a href="#Singleton-Classes-and-Inheritance-单例类的继承关系" class="headerlink" title="Singleton Classes and Inheritance (单例类的继承关系)"></a>Singleton Classes and Inheritance (单例类的继承关系)</h3><blockquote>
<p>还记得我说过类也是对象, 那么类方法就可以看成是类这种对象的单例方法.所以, 和对象单例方法类似地, 可以这样定义类方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class C</span><br><span class="line">  class &lt;&lt; self</span><br><span class="line">    def a_class_method</span><br><span class="line">      &apos;C.a_class_method&apos;</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在类的singleton class:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C.singleton_class # =&gt; #&lt;Class:C&gt;</span><br><span class="line">D.singleton_class # =&gt; #&lt;Class:D&gt;</span><br><span class="line">D.singleton_class.superclass # =&gt; #&lt;Class:C&gt;</span><br><span class="line">C.singleton_class.superclass # =&gt; #&lt;Class:Object&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用一张图表示这种继承关系:</p>
</blockquote>
<p><img src="http://i2.tietuku.com/b161c0e3d108e867.png"></p>
<blockquote>
<p>Ruby这样组织classes, singleton classes, and superclasses 是有目的的. #D的父类是#C, 又是C的singleton class, 同样的, #C的父类是#Object. 由于这样组织, 我可以在子类中调用父类的类方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D.a_class_method # =&gt; &quot;C.a_class_method()&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>D 现在#D查找, 发现没有再去#C查找.</p>
</blockquote>
<h3 id="The-Great-Unified-Theory"><a href="#The-Great-Unified-Theory" class="headerlink" title="The Great Unified Theory"></a>The Great Unified Theory</h3><blockquote>
<p>把singleton class和class 和module放到一起, 关于 Ruby object model的总结:</p>
</blockquote>
<ul>
<li>只有一种对象, 是标准的object或者是module</li>
<li>只有一种module, 是标准的module, class, 或者是singleton class</li>
<li>只有一种方法, 它在module中, 多数在class中</li>
<li>class的每一个对象都有自己的真正的class, 是标准的class或者singleton class</li>
<li>除了BasicObject的每一个class, 都只有一个祖先, 父类或者module. 也就是说只有一条继承链到达BasicObject</li>
<li>一个对象的singleton class的父类是这个对象所属的类. 一个class的singleton class的父类是这个class的父类的singleton class.</li>
<li>当你调用一个方法时, Ruby向右到接收者的真的class(singleton class), 然后沿着继承链向上来寻找这个方法.</li>
</ul>
<p>&gt;</p>
<h3 id="Class-Methods-Syntaxes"><a href="#Class-Methods-Syntaxes" class="headerlink" title="Class Methods Syntaxes"></a>Class Methods Syntaxes</h3><blockquote>
<p>有3中方法可以定义类方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def MyClass.a_class_method; end</span><br><span class="line"></span><br><span class="line">class MyClass</span><br><span class="line">  def self.a_class_method</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">class MyClass</span><br><span class="line">  class &lt;&lt; self</span><br><span class="line">    def a_class_method; end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="Singleton-Classes-and-instance-eval"><a href="#Singleton-Classes-and-instance-eval" class="headerlink" title="Singleton Classes and instance_eval()"></a>Singleton Classes and instance_eval()</h3><blockquote>
<p>之前说<code>instance_eval</code>改变的是<code>self</code>, <code>class_eval</code>既可以改变<code>self</code>又可以改变current class. 其实, <code>instance_eval</code> 也可以改变current class. 它改变接收者的singleton class, 我们可以用它为对象定义一个singleton 方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s1, s2 = &quot;abc&quot;, &quot;def&quot;</span><br><span class="line"></span><br><span class="line">s1.instance_eval do</span><br><span class="line">  def swoosh!; reverse; end</span><br><span class="line">end</span><br><span class="line">s1.swoosh! # =&gt; &quot;cba&quot;</span><br><span class="line"></span><br><span class="line">s2.respond_to?(:swoosh!) # =&gt; false</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所以 <code>instance_eval</code>的含义是”我要改变self”</p>
</blockquote>
<h3 id="Class-Attributes"><a href="#Class-Attributes" class="headerlink" title="Class Attributes"></a>Class Attributes</h3><blockquote>
<p>之前学过Class Macros 针对对象添加属性:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line">  attr_accessor :a</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>刚才说过, 其实不存在属性, 所谓属性不过是一对方法而已, 那么可以利用singleton class:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line">  class &lt;&lt; self</span><br><span class="line">    attr_accessor :b</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">MyClass.c = &apos;It works!&apos;</span><br><span class="line">MyClass.c # =&gt; &quot;It works!&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>下面的图可以帮助理解这个问题:</p>
</blockquote>
<p><img src="http://i2.tietuku.com/ea88a1ff55723a40.png"></p>
<h2 id="Quiz-Module-Trouble"><a href="#Quiz-Module-Trouble" class="headerlink" title="Quiz: Module Trouble"></a>Quiz: Module Trouble</h2><blockquote>
<p>类方法(singleton method)的继承:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module MyModule</span><br><span class="line">  def self.my_method; &apos;hello&apos;; end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">class MyClass</span><br><span class="line">  include MyModule</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">MyClass.my_method # NoMethodError!</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要让MyClass的singleton class include MyModule, 并且my_method不可以是类方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module MyModule</span><br><span class="line">  def my_method; &apos;hello&apos;; end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">class MyClass</span><br><span class="line">  class &lt;&lt; self</span><br><span class="line">    include MyModule</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="Class-Methods-and-include"><a href="#Class-Methods-and-include" class="headerlink" title="Class Methods and include()"></a>Class Methods and include()</h3><blockquote>
<p>不仅是类方法, 对象的singleton method 也可以继承module的方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj = Object.new</span><br><span class="line">class &lt;&lt; obj</span><br><span class="line">  include MyModule</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">obj.my_method # =&gt; &quot;hello&quot;</span><br><span class="line">obj.singleton_methods # =&gt; [:my_method]</span><br></pre></td></tr></table></figure>
<h3 id="Object-extend"><a href="#Object-extend" class="headerlink" title="Object#extend"></a>Object#extend</h3><blockquote>
<p><code>extend</code>方法直接将MyModule的方法扩展为扩展为自己的单例方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module MyModule</span><br><span class="line">  def my_method; &apos;hello&apos;; end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">obj = Object.new</span><br><span class="line">obj.extend MyModule</span><br><span class="line">obj.my_method #=&gt; &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">class MyClass</span><br><span class="line">  extend MyModule</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">MyClass.my_method #=&gt; &quot;hello&quot;</span><br></pre></td></tr></table></figure>
<h2 id="Method-Wrappers"><a href="#Method-Wrappers" class="headerlink" title="Method Wrappers"></a>Method Wrappers</h2><blockquote>
<p>需要解决的问题: 你有一个方法, 但是你并不想直接修改它, 因为它在库中.你想围绕这个方法添加一些功能.</p>
</blockquote>
<h3 id="Around-Aliases"><a href="#Around-Aliases" class="headerlink" title="Around Aliases"></a>Around Aliases</h3><blockquote>
<p>使用<code>Module#alias_method</code>可以Ruby的方法起一个别名:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line">  def my_method</span><br><span class="line">    &apos;my_method&apos;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  alias_method :m, :my_method</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">obj = MyClass.new</span><br><span class="line">obj.my_method # =&gt; &quot;my_method()&quot;</span><br><span class="line">obj.my_method # =&gt; &quot;my_method()&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>别名在Ruby中很常见, 比如<code>String#size</code>就是<code>String#length</code>的别名.所以我可以使用下面的技巧:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class String</span><br><span class="line">  alias_method :real_length, :length</span><br><span class="line"></span><br><span class="line">  def length </span><br><span class="line">    real_length &gt; 5 ? &apos;long&apos; : &apos;short&apos;</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">&quot;War and Peace&quot;.length # =&gt; &quot;long&quot;</span><br><span class="line">&quot;War and Peace&quot;.real_length # =&gt; 13</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我不想扔到String 原有的功能, 所以我使用<code>alias_method</code>把它的功能转移给<code>real_length</code>方法, 然后再重新定义<code>length</code><br>写一个别名方法可以归纳为3步:</p>
</blockquote>
<ul>
<li>使用<code>alias_method</code>为一个方法起别名</li>
<li>重新定义这个方法</li>
<li>在这个方法定义中调用老的方法(real_length)</li>
</ul>
<blockquote>
<p>但是对于Aliases来说, 它是一种Monkeypatching, 它破坏了已经存在的代码, 所以从Ruby2.0开始引入了另外一种方式为已存在的方法扩展功能.</p>
</blockquote>
<h3 id="More-Method-Wrappers"><a href="#More-Method-Wrappers" class="headerlink" title="More Method Wrappers"></a>More Method Wrappers</h3><blockquote>
<p>我们都知道Refinements可以弥补Monkeypatching的不足, 我可以使用它来取代Aliases, 如果在<code>refine</code>中使用<code>super</code>关键字, 它就会调用原始的方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module StringRefinement</span><br><span class="line">  refine String do</span><br><span class="line">    def length</span><br><span class="line">      super &gt; 5 ? &apos;long&apos; : &apos;short&apos;</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">using StringRefinement</span><br><span class="line"></span><br><span class="line">puts &quot;War and Peace&quot;.length     #=&gt; long</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样写更加安全, 不会污染其他的类.<br>最后还有一种方式来包装方法—<code>Module#prepend</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">module ExplicitString</span><br><span class="line">  def length</span><br><span class="line">    super &gt; 5 ? &apos;long&apos; : &apos;short&apos;</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">String.class_eval do</span><br><span class="line">  prepend ExplicitString</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">puts &quot;fdsfsfds&quot;.length   #=&gt; long</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/26/ruby-metaprogramming-chpt4-blocks/" itemprop="url">
                  Ruby 元编程 第四章 Blocks
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-26T10:53:25+08:00" content="2015-03-26">
              2015-03-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Ruby/" itemprop="url" rel="index">
                    <span itemprop="name">Ruby</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Block 可以控制scope, 即: 哪些变量和方法对于哪几行代码是可见的.在本章你会发现这种对于scope的控制如何让block成为Ruby元编程的基础.</p>
<p>Block仅仅是<code>callable objects</code>(可调用对象)这个大家族中的一员, 它还包括<code>proc</code>, <code>lambda</code>等. 本章将要向你展示这些<code>callable objects</code>的有利之处—比如: 存储block, 以后执行.</p>
<p>Block概念可以追溯到函数式编程, 如LISP语言.</p>
</blockquote>
<h2 id="The-Basics-of-Blocks-Block的基础知识"><a href="#The-Basics-of-Blocks-Block的基础知识" class="headerlink" title="The Basics of Blocks(Block的基础知识)"></a>The Basics of Blocks(Block的基础知识)</h2><blockquote>
<p>回忆一下block是怎么样工作的:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def a_method(a, b)</span><br><span class="line">  a + yield(a, b)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">a_method(1, 2) &#123; |x, y| (x+y) * 3 &#125;</span><br><span class="line"></span><br><span class="line"># =&gt; 10</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以使用<code>do end</code>, 其一般用来包裹多行代码.</p>
<p>只有在你调用方法的时候才可以定义block, block直接被传给了方法, 方法可以通过yield关键字回调block.<br>block可以选择性地具有参数, 比如前面例子的<code>x</code>,<code>y</code>. 在方法中使用yield的时候, 可以通过yield为block的参数传值. 和方法的返回值一样, block的返回值也是它最后一行代码执行的结果.</p>
<p>在方法中, 可以使用<code>Kernel#block_given?</code>判断该方法在被调用时是否带有一个block.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def a_method</span><br><span class="line">  return yield if block_given?</span><br><span class="line"></span><br><span class="line">  &quot;No Block&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a_method # =&gt; &quot;no block&quot;</span><br><span class="line">a_method &#123; &quot;here&apos;s a block!&quot;  &#125;  # =&gt; &quot;here&apos;s a block!&quot;</span><br></pre></td></tr></table></figure>
<h3 id="利用block来定义一个transaction方法"><a href="#利用block来定义一个transaction方法" class="headerlink" title="利用block来定义一个transaction方法"></a>利用block来定义一个transaction方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module Kernel</span><br><span class="line">  def using(resource)</span><br><span class="line">    begin</span><br><span class="line">      yield</span><br><span class="line">    ensure</span><br><span class="line">      resource.close</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">r = Resource.new</span><br><span class="line">using(r) &#123;</span><br><span class="line">  raise Exception</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>即便是发生了异常, 资源r也会被正常关闭.</p>
</blockquote>
<h2 id="Blocks-Are-Closures-Block是闭包"><a href="#Blocks-Are-Closures-Block是闭包" class="headerlink" title="Blocks Are Closures (Block是闭包)"></a>Blocks Are Closures (Block是闭包)</h2><blockquote>
<p>我们将会看到如何通过block跨越scope走私变量(smuggle variables across scopes)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def my_method</span><br><span class="line">  x = &quot;Goodbye&quot;</span><br><span class="line">  yield(&quot;cruel&quot;)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">x = &quot;Hello&quot;</span><br><span class="line"></span><br><span class="line">my_method &#123; |y| &quot;#&#123;x&#125;, #&#123;y&#125; world&quot; &#125;</span><br><span class="line"></span><br><span class="line"># =&gt; &quot;Hello, cruel world&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结合上面的代码, 当你创建了一个block时, 你就已经捕获到了本地绑定, 比如: x, 值为”Hello” 然后你把block传给了一个方法, 该方法有它自己的独立的绑定, 它是值为”Goodbye”的x.但block不认这个方法中的x.<br>你也可以在block中定义一个附加的绑定, 但是block执行完就会消失:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def just_yield</span><br><span class="line">  yield</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">top_level_variable = 1</span><br><span class="line"></span><br><span class="line">just_yield do</span><br><span class="line">  top_level_variable += 1</span><br><span class="line">  local_to_block = 1</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">puts top_level_variable </span><br><span class="line">puts local_to_block</span><br><span class="line"></span><br><span class="line">top_level_variable # =&gt; 2</span><br><span class="line">local_to_block # =&gt; Error!</span><br></pre></td></tr></table></figure>
<blockquote>
<p>block就是闭包(closure), 通俗理解, 闭包就是block捕捉本地绑定并持有这个本地绑定.<br>那么该如何将闭包应用于实际呢? 首先要搞清楚所有的绑定在哪里被记住了—scope. 你将会了解程序在哪里改变scope, 以及遇到改变了scope引发的特别的问题, 这个问题可以使用闭包来解决.</p>
</blockquote>
<h3 id="Scope-范围"><a href="#Scope-范围" class="headerlink" title="Scope (范围)"></a>Scope (范围)</h3><blockquote>
<p>把自己想象成一个断点调试工具, 一点点地穿越整个Ruby程序, 从一个语句跳转到另一个语句, 直到到达断点, 你的周围就是scope.<br>你可以看到整个scope到处是scope, 向下看看你的脚, 你会看到一堆本地变量, 抬起头你发现你处于对象中, 有它自己的方法, 和实例变量, 这就是当前对象, 也就是<code>self</code>. 往远处看, 你看到有常量(constants)构成的树, 你可以在地图标记出你的位置, 再看远些, 你甚至会看到一堆全局变量($).<br>以上这段描绘一幅Ruby程序的画面</p>
</blockquote>
<h3 id="Changing-Scope"><a href="#Changing-Scope" class="headerlink" title="Changing Scope"></a>Changing Scope</h3><blockquote>
<p>下面的例子展示了程序运行时scope是如何改变的, 使用<code>Kernel#local_variables</code>方法来追踪绑定名称:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">v1 = 1</span><br><span class="line">local_variables # =&gt; [:v1]</span><br><span class="line">class MyClass</span><br><span class="line">  v2 = 2</span><br><span class="line">  local_variables # =&gt; [:v2]</span><br><span class="line">  </span><br><span class="line">  def my_method</span><br><span class="line">    v3 = 3</span><br><span class="line">    local_variables</span><br><span class="line">  end</span><br><span class="line">  local_variables</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">obj = MyClass.new</span><br><span class="line">obj.my_method # =&gt; [:v3]</span><br><span class="line">obj.my_method # =&gt; [:v3]</span><br><span class="line">local_variables # =&gt; [:v1, :obj]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>程序开始执行, 在top-level scope(main, 解释器提供的)中定义了v1, 然后程序进入了<code>MyClass</code>的定义中, v1就不可见了, 又定义了v2和一个方法, 但是方法中的代码还没有执行, 所以方法的scope在MyClass定义完成之前是永远不会打开的, 等到class的定义结束, 方法<code>my_method</code>的scope才会打开, 这时程序回到了top-level scope.</p>
<p>调用my_method方法的时候, 程序打开一个新的scope, 然后定义了一个<code>local variables</code> v3, 然后程序退出方法, 退回到top-level, 第二次调用方法时, 有打开了一个新的scope, 定义了一个新的<code>local variables</code> v3, 和之前的v3不同, 因为之前的已经失效了.<br>最后程序程序又返回top-level, 所以<code>local variables</code>又是<code>v1</code> 和 <code>obj</code> 了.</p>
<p>这个例子有一个要点: <strong><em>不管什么时候程序改变了scope, 一些绑定被新的所替代</em></strong>, 但不都是这样的, 同一个对象的一个方法去调用了另一个方法, 实例变量是不会失效, 一般来说, 当scope改变时, 绑定更加倾向于失效.尤其地, 每改变一次新的scope, 本地变量就会发生改变. 这也就是为什么它叫”本地”的原因了.</p>
</blockquote>
<h3 id="Scope-Gates-Scope-关口"><a href="#Scope-Gates-Scope-关口" class="headerlink" title="Scope Gates (Scope 关口)"></a>Scope Gates (Scope 关口)</h3><blockquote>
<p>Scope Gate是程序离开前一个scope进入下一个的位置, 可以是下面的几个位置:</p>
</blockquote>
<ul>
<li>Class definitions</li>
<li>Module definitions</li>
<li>Method definitions</li>
</ul>
<blockquote>
<p>程序进入class, module, method 定义时, scope就会发生改变. 也可以说进入3个关键词—<code>class</code>, <code>module</code>, <code>def</code>. 每个关键词就扮演着<code>Scope Gate</code>的角色.<br>接下来就在前面的例子中标记出来这些Scope Gates:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">v1 = 1</span><br><span class="line">local_variables # =&gt; [:v1]</span><br><span class="line">class MyClass   # SCOPE GATE: entering class</span><br><span class="line">  v2 = 2</span><br><span class="line">  local_variables # =&gt; [:v2]</span><br><span class="line">  </span><br><span class="line">  def my_method # SCOPE GATE: entering def</span><br><span class="line">    v3 = 3</span><br><span class="line">    local_variables</span><br><span class="line">  end            # SCOPE GATE: leaving def</span><br><span class="line">  local_variables</span><br><span class="line">end               # SCOPE GATE: leaving class</span><br><span class="line"></span><br><span class="line">obj = MyClass.new</span><br><span class="line">obj.my_method # =&gt; [:v3]</span><br><span class="line">obj.my_method # =&gt; [:v3]</span><br><span class="line">local_variables # =&gt; [:v1, :obj]</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>class</code>, <code>module</code> 和 <code>def</code> 还有一些微妙的区别: 在class 或者module的定义中的代码马上被执行.而方法是在方法被调用的时候里面的代码才会执行.</p>
</blockquote>
<h3 id="Flattening-the-Scope-摧毁Scope"><a href="#Flattening-the-Scope-摧毁Scope" class="headerlink" title="Flattening the Scope (摧毁Scope)"></a>Flattening the Scope (摧毁Scope)</h3><blockquote>
<p>现在我们可以辨别出程序在哪里改变scope了, 但是该如何在他们直接传递变量呢? 这个问题需要再回过头来看block.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_var = &quot;Success&quot;</span><br><span class="line">class MyClass</span><br><span class="line">  # We want to print my_var here...</span><br><span class="line">  def my_method</span><br><span class="line">    # ..and here</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如何让<code>my_var</code>穿过这两个Scope Gates呢?<br>由于<code>class</code>是Gate, 所以需要想办法替换掉<code>class</code>关键字, 它就是<code>Class.new do ... #{my_var} ... end</code>这样的一个方法调用, 这样把<code>my_var</code>放到了闭包中:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_var = &quot;Success&quot;</span><br><span class="line">MyClass = Class.new do</span><br><span class="line">  puts &quot;#&#123;my_var&#125;&quot;</span><br><span class="line"></span><br><span class="line">  def my_method</span><br><span class="line">    # ...but how can we print it here?</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同理, 若想在<code>my_method</code>也可以访问<code>my_var</code>, 就要想办法去掉关键字<code>def</code>, 那么只能使用动态方法定义了:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">my_var = &quot;Success&quot;</span><br><span class="line"></span><br><span class="line">MyClass = Class.new do</span><br><span class="line"></span><br><span class="line">  &quot;#&#123;my_var&#125; in the class definition&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  define_method :my_method do</span><br><span class="line">    &quot;#&#123;my_var&#125; in the method&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass.new.my_method</span><br><span class="line">Success in the class definition</span><br><span class="line">Success in the class definition</span><br></pre></td></tr></table></figure>
<h4 id="Sharing-the-Scope"><a href="#Sharing-the-Scope" class="headerlink" title="Sharing the Scope"></a>Sharing the Scope</h4><blockquote>
<p>在几个方法之间共享变量, 并且不想让别人看到这个变量, 可以把这几个方法定义在同一个 Flat Scope中:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def define_methods</span><br><span class="line">  shared = 0</span><br><span class="line"></span><br><span class="line">  Kernel.send :define_method, :counter do</span><br><span class="line">    shared</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  Kernel.send :define_method, :inc do |v|</span><br><span class="line">    shared += v</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># irb</span><br><span class="line">load FIlENAME</span><br><span class="line"></span><br><span class="line">define_methods</span><br><span class="line">counter # =&gt; 0</span><br><span class="line"></span><br><span class="line">inc(4)</span><br><span class="line">counter # =&gt; 4</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于<code>define_methods</code> 作为Scope Gate, 其他方法访问不到 变量<code>shared</code>, 只有<code>counter</code>和<code>inc</code>可以访问到<code>shared</code>, 这种巧妙控制共享变量的方法就是”Shared Scope”</p>
</blockquote>
<h3 id="Closures-Wrap-Up"><a href="#Closures-Wrap-Up" class="headerlink" title="Closures Wrap-Up"></a>Closures Wrap-Up</h3><blockquote>
<p>每个Ruby scope都包含许多绑定(local变量), 这些scope被Scope Gates(class, module, def)分开.<br>如果你想让绑定通过Scope Gate, 你可以使用block, block是一个闭包(closure): 你定义一个block时, 它会持有当前环境的绑定. 所以你可以将Scope Gate替换为方法调用的形式, 在闭包(block)中获取当前的绑定, 再把闭包传给方法.<br>你可以使用<code>Class.new</code>代替<code>class</code>关键字, <code>Module.new</code>代替<code>module</code>关键字, <code>Module#define_method</code>代替<code>def</code>关键字. 这就是<code>Flat Scope</code>, 基本的闭包相关处理方法.<br>如果你在一个Flat Scope 中定义了多个方法, 就可能被Scope Gate保护, 所有的这些方法可以共享绑定, 这就是<code>Shared Scope</code></p>
</blockquote>
<h2 id="instance-eval"><a href="#instance-eval" class="headerlink" title="instance_eval()"></a>instance_eval()</h2><blockquote>
<p><code>instance_eval()</code> 是另一种让你把代码和绑定融合的方法.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line">  def initialize</span><br><span class="line">    @v = 1</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">obj = MyClass.new</span><br><span class="line">obj.instance_eval do</span><br><span class="line">  self # =&gt; #&lt;MyClass:0x3340dc @v=1&gt;</span><br><span class="line">  @v # =&gt; 1</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>block会把接收者作为self, 所以它可以访问接收者的私有方法和实例变量, 比如@v.<br>我可以通过block修改对象的实例变量的值:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v = 2</span><br><span class="line">obj.instance_eval &#123; @v = v &#125;</span><br><span class="line">obj.instance_eval &#123; @v &#125; # =&gt; 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们把传给 <code>instance_eval</code>的block叫做”Context Probe(环境探测), 因为它像是一段代码潜入对象内部.</p>
</blockquote>
<h3 id="instance-exec"><a href="#instance-exec" class="headerlink" title="instance_exec()"></a>instance_exec()</h3><blockquote>
<p><code>instance_eval</code>还有一个同门师弟<code>instance_exec</code>, 它允许你给block传递参数:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class C</span><br><span class="line">  def initialize</span><br><span class="line">    @x = 1</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">class D</span><br><span class="line">  def twisted_method</span><br><span class="line">    @y = 2</span><br><span class="line">    C.new.instance_eval &#123; puts &quot;@x: #&#123;@x&#125;, @y: #&#123;@y&#125;&quot; &#125;</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">D.new.twisted_method # =&gt; @x: 1, @y:</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在使用的方法是<code>instance_eval</code>, 我们发现<code>@y</code>的值并没有获取到, 因为在<code>twisted_method</code>切换了receiver, 原本是D的实例, 现在变成了C的实例(C.new), 那么实例变量<code>@y</code>就脱离了原来的scope, block中的代码会把<code>@y</code>解释成C没有被初始化的实例变量, 也就是<code>nil</code>.<br>那么这时候就该使用<code>instance_exec</code>了, 它可以传递到C的scope中.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class C</span><br><span class="line">  def initialize</span><br><span class="line">    @x = 1</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">class D</span><br><span class="line">  def twisted_method</span><br><span class="line">    @y = 2</span><br><span class="line">    C.new.instance_exec(@y) &#123; |y| puts &quot;@x: #&#123;@x&#125;, @y: #&#123;y&#125;&quot; &#125;</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">D.new.twisted_method # =&gt; @x: 1, @y: 2</span><br></pre></td></tr></table></figure>
<h3 id="Breaking-Encapsulation-打开包装"><a href="#Breaking-Encapsulation-打开包装" class="headerlink" title="Breaking Encapsulation (打开包装)"></a>Breaking Encapsulation (打开包装)</h3><blockquote>
<p>那么我们为什么要内窥对象呢? 如, 有时候在irb中看看对象内部, 所以使用<code>instance_eval</code>是最快捷的方法.<br>还有一个原因修改一个已经存在的对象的属性, 而不是创建一个新的, 比如:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Padrino.logger.instance_eval&#123; @log_static = true &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Clean-Rooms"><a href="#Clean-Rooms" class="headerlink" title="Clean Rooms"></a>Clean Rooms</h3><blockquote>
<p>有时候你创建对象只是为了运行其中的block. 这样的对象就是”Clean Room”:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class CleanRoom</span><br><span class="line">  def current_temperature</span><br><span class="line">  # ...</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">clean_room = CleanRoom.new</span><br><span class="line">clean_room.instance_eval do</span><br><span class="line">  if current_temperature &lt; 30</span><br><span class="line">    # ...</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个CleanRoom只是你运行你block的一个环境, 它暴露了一些有用的方法来给block调用, 比如说例子中的<code>current_temperature</code>, 但是一个理想的 Clean Room不应该有许多方法或者实例变量, 因为这些方法或者实例变量的名称可能会和block中的发生冲突. 正是因为如此, BasicObject的实例适合作为 Clean Rooms, 因为它是 Blank Slates, 几乎没有什么方法. 有意思的是,  BasicObject 比这还要干净, 连String都是out of scope, 如果要从BasicObject引用常量, 你必须使用绝对路径, `::String</p>
</blockquote>
<h2 id="Callable-Objects-可调用对象"><a href="#Callable-Objects-可调用对象" class="headerlink" title="Callable Objects (可调用对象)"></a>Callable Objects (可调用对象)</h2><blockquote>
<p>可以将block的执行归纳为2步, 第一步: “先设置一段代码, 放在那里”, 第二步: “使用yield执行该代码”. 其实Ruby中还有几种对象支持这种机制. 你可以在以下对象中打包代码:</p>
</blockquote>
<ul>
<li>proc, block被转换成对象的形式.</li>
<li>lambda, proc的变种.</li>
<li>method (方法)</li>
</ul>
<h3 id="Proc-Objects"><a href="#Proc-Objects" class="headerlink" title="Proc Objects"></a>Proc Objects</h3><blockquote>
<p>Proc对象就是block转成object. Proc通过传给<code>Proc.new</code> 一个block的方法创建. 之后通过<code>Proc#call</code>调用这个转换的block.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inc = Proc.new &#123; |x| x + 1 &#125;</span><br><span class="line">inc.call(3) # =&gt; 4</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line">inc = proc &#123; |x| x + 1 &#125;</span><br><span class="line">inc.call 3 # =&gt; 4</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种技术称为 “Defferred Evaluation”(延期求值)</p>
<p>你还可以使用<code>Module#lambda</code>来将block转换成<code>proc</code>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dec = lambda &#123;|x| x - 1 &#125; </span><br><span class="line">dec.class # =&gt; Proc </span><br><span class="line">dec.call(2) # =&gt; 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你也可以使用<code>-&gt;</code> 代替<code>lambda</code>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = -&gt;(x) &#123; x + 1 &#125;</span><br><span class="line"></span><br><span class="line"># 等价于</span><br><span class="line"></span><br><span class="line">p = lambda &#123; |x| x + 1 &#125;</span><br></pre></td></tr></table></figure>
<h3 id="The-amp-Operator"><a href="#The-amp-Operator" class="headerlink" title="The &amp; Operator"></a>The &amp; Operator</h3><blockquote>
<p>对于一个方法来说, block 像是一个附加的匿名的参数. 在大多数情况下, 你可以通过在方法中使用<code>yield</code>执行block. 但是在下面的2个例子中, yield是不够的:</p>
</blockquote>
<ul>
<li>你想把block传递给另一个方法或者block</li>
<li>你想把block转换成Proc</li>
</ul>
<blockquote>
<p>因为在这两种情况下, 需要指出block的名字.为了给block加上一个绑定, 可以给方法添加一个特别的参数来代表这个block, 这个参数必须是方法的最后一个参数并且添加一个<code>&amp;</code>符号作为前缀:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def math(a, b)</span><br><span class="line">  yield(a, b)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def do_math(a, b, &amp;operation)</span><br><span class="line">  math(a, b, &amp;operation)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">do_math(2,3)&#123;|x,y|x*y&#125; #=&gt;6</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你没有给<code>do_math</code>提供block, <code>&amp;operation</code>就为nil, yield就会调用失败, 因为没有提供block</p>
<p>那么第二种情况把block转换成Proc呢? 其实上个例子中引用的<code>operation</code>就是Proc, <code>&amp;</code>符号的真正是”我想把block带到这个方法中, 把它转成Proc”, 去掉<code>&amp;</code>就是Proc的部分:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def my_method(&amp;the_proc)</span><br><span class="line">  the_proc</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">my_method &#123; |name| &quot;Hello, #&#123;name&#125;!&quot;  &#125;</span><br><span class="line">p.class # =&gt; Proc</span><br><span class="line">p.call(&quot;Bill&quot;) # =&gt; &quot;Hello, Bill!&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>那么如何将proc转成一个block? 还是使用<code>&amp;</code>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def my_method(greeting)</span><br><span class="line">  &quot;#&#123;greeting&#125; #&#123;yield&#125;&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">my_proc = proc &#123; &quot;Bill&quot; &#125;</span><br><span class="line"></span><br><span class="line">my_method(&quot;Hello&quot;, &amp;my_proc)</span><br></pre></td></tr></table></figure>
<h4 id="The-HighLine-Example"><a href="#The-HighLine-Example" class="headerlink" title="The HighLine Example"></a>The HighLine Example</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">require &apos;highline&apos;</span><br><span class="line">hl = HighLine.new</span><br><span class="line">friends = hl.ask(&quot;Friends?&quot;, lambda &#123;|s| s.split(&apos;,&apos;) &#125;)</span><br><span class="line">puts &quot;You&apos;re friends with: #&#123;friends.inspect&#125;&quot;</span><br><span class="line">❮ Friends?</span><br><span class="line">➾ Ivana, Roberto, Olaf # 输入</span><br><span class="line">❮ You&apos;re friends with: [&quot;Ivana&quot;, &quot; Roberto&quot;, &quot; Olaf&quot;]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>等用户输入完成以后, proc才会被调用.</p>
</blockquote>
<h3 id="Procs-vs-Lambdas"><a href="#Procs-vs-Lambdas" class="headerlink" title="Procs vs. Lambdas"></a>Procs vs. Lambdas</h3><blockquote>
<p>到目前, 把block转换成proc的方法有: Proc.new, proc, lambda, &amp; 操作符. 结果都是Proc对象.</p>
<p>但事实上, 由lambda方法创建的Proc(后面称lambdas) 和其他方法创建的Proc(后面称procs)还有有区别的. 判断一个Proc对象是不是lambda可以使用<code>Proc#lambda?</code></p>
<p>下面就比较以下两种的区别:</p>
</blockquote>
<h4 id="Procs-Lambdas-and-return"><a href="#Procs-Lambdas-and-return" class="headerlink" title="Procs, Lambdas, and return"></a>Procs, Lambdas, and return</h4><blockquote>
<p>Proc 和 Lambdas中return的意义不同, lambdas返回的只是lambdas内部的值, 它所被调用的方法的返回值依旧正常返回.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def test_lambda_return</span><br><span class="line">  l = lambda &#123; return 10 &#125;</span><br><span class="line">  l.call</span><br><span class="line">  return &quot;hello&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">test_lambda_return # =&gt; &quot;hello&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>而 proc的返回值, 就是代表整个scope(方法)的返回值了:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def test_proc_return</span><br><span class="line">  p = proc &#123; return 10 &#125;</span><br><span class="line">  p.call</span><br><span class="line">  return &quot;hello&quot; # =&gt; 执行不到这里</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">test_proc_return # =&gt; 10</span><br></pre></td></tr></table></figure>
<blockquote>
<p>proc返回值指的就是其被定义所在的scope的返回值, 使用时需要谨慎, 比如下面的例子的错误就是由于在top-level定义了scope, 却在一个方法这样的scope中返回, 引起了错误:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def double(callable_abject)</span><br><span class="line">  callable_abject.call * 2</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">p = Proc.new &#123; return 10 &#125;</span><br><span class="line">double(p) # =&gt; LocalJumpError</span><br></pre></td></tr></table></figure>
<blockquote>
<p>避免明确使用return:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = Proc.new &#123; 10 &#125;</span><br><span class="line"></span><br><span class="line">double(p) # =&gt; 20</span><br></pre></td></tr></table></figure>
<h4 id="Procs-Lambdas-and-Arity-参数数量"><a href="#Procs-Lambdas-and-Arity-参数数量" class="headerlink" title="Procs, Lambdas, and Arity (参数数量)"></a>Procs, Lambdas, and Arity (参数数量)</h4><blockquote>
<p>Proc和Lambdas对于参数数量不匹配时的”容忍度”不同, Proc在参数数量不匹配的情况下, 不会报错, 如果参数个数不够, 它会使用nil代替, 如果参数个数过多, 它会去掉后面的参数, 只保留定义的参数数量, 而Lambdas只有参数数量不符合就会报错:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p = Proc.new &#123;|a, b| [a, b]&#125;</span><br><span class="line">p.call(1, 2, 3) # =&gt; [1, 2]</span><br><span class="line">p.call(1)    # =&gt; [1, nil]</span><br><span class="line"></span><br><span class="line">l = lambda &#123; |a, b| [a, b] &#125;</span><br><span class="line"></span><br><span class="line">l.call (1, 2, 3)</span><br><span class="line"># =&gt;</span><br><span class="line">ArgumentError: wrong number of arguments (0 for 2)</span><br><span class="line">from (irb):25:in `block in irb_binding&apos;</span><br><span class="line">from (irb):31:in `call&apos;</span><br><span class="line">from (irb):31</span><br><span class="line">from /Users/daniel/.rvm/rubies/ruby-2.2.0/bin/irb:11:in `&lt;main&gt;&apos;&apos;`</span><br></pre></td></tr></table></figure>
<h4 id="Procs-vs-Lambdas-The-Verdict-结论"><a href="#Procs-vs-Lambdas-The-Verdict-结论" class="headerlink" title="Procs vs. Lambdas: The Verdict (结论)"></a>Procs vs. Lambdas: The Verdict (结论)</h4><blockquote>
<p>lambdas比proc更加敏感, 对参数严格, 使用return它就终止, 可见它更像是方法. 所以尽量使用lambda, 除非你真的需要procs的一些特性.</p>
</blockquote>
<h3 id="Method-Objects-方法对象"><a href="#Method-Objects-方法对象" class="headerlink" title="Method Objects (方法对象)"></a>Method Objects (方法对象)</h3><blockquote>
<p>看看方法是如何打包代码, 以后使用的. 方法也是callable objects 中的一员:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line">  def initialize(value)</span><br><span class="line">    @x = value</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def my_mythod</span><br><span class="line">    @x</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">object = MyClass.new(1)</span><br><span class="line"></span><br><span class="line">m = object.method :my_mythod</span><br><span class="line">m.call # =&gt; 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过调用了<code>Kernel#method</code>方法, 可以把方法本身变成一个<code>Method</code>对象, 以后调用.Ruby2.1以后, 可以通过<code>Kernel#singleton_method</code>方法把<code>Singleton Method</code>转换成Method 对象.<br>Method 对象和block, lambda相似. 可以通过<code>Method#to_proc</code>转换成proc对象, 也可以通过<code>define_method</code>把block转换成method对象.</p>
<p>但是lambdas和method的一个很大的区别就在于scope, lambdas的在其被定义的scope内求值, 它是闭包的, 而Method是在它的对象scope内求值的.<br>Ruby还有一种方式表示方法: <code>Unbound Methods</code></p>
</blockquote>
<h4 id="Unbound-Methods"><a href="#Unbound-Methods" class="headerlink" title="Unbound Methods"></a>Unbound Methods</h4><blockquote>
<p>Unbound Methods就是没有与具体的对象绑定到一起的方法. 你可以使用<code>Method#unbind</code>将一个Method对象转换成Unbound Method, 也可以使用<code>Module#instance_method</code>直接获得<code>UnboundMethod</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module MyModule</span><br><span class="line">  def my_method</span><br><span class="line">    52</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">unbound = MyModule.instance_method(:my_method)</span><br><span class="line">unbound.class # # =&gt; UnboundMethod</span><br></pre></td></tr></table></figure>
<blockquote>
<p>UnboundMethod 不能被调用, 可以先让UnboundMethod与某个对象绑定, 再调用, 使用的方法是<code>UnboundMethod#unbound(:some_obj)</code>, 前提<code>some_obj</code>和UnboundMethod必须来自于同一个类, 或子类.<br>另外还可以通过<code>define_method</code>把UnboundMethod 绑定为一个类的方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String.class_eval do</span><br><span class="line">  define_method :another_method, unbound</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">&quot;abc&quot;.another_method # =&gt; 42</span><br></pre></td></tr></table></figure>
<h4 id="The-Active-Support-Example"><a href="#The-Active-Support-Example" class="headerlink" title="The Active Support Example"></a>The Active Support Example</h4><blockquote>
<p>对于某些特殊情况, 又想用回原来的<code>Kernel#load</code>方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module Loadable</span><br><span class="line">  def load</span><br><span class="line">    #  覆盖掉Module#load方法</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  # 对于某些类来说, 还需使用Kernel#load方法</span><br><span class="line"></span><br><span class="line">  def self.exclude_from(base)</span><br><span class="line">    base.class_eval &#123; define_method :load, Kernel.instance_method(:load) &#125;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  [...]</span><br></pre></td></tr></table></figure>
<h3 id="Callable-Objects-Wrap-Up"><a href="#Callable-Objects-Wrap-Up" class="headerlink" title="Callable Objects Wrap-Up"></a>Callable Objects Wrap-Up</h3><blockquote>
<p>Callable objects是是代码片段, 你可以求它的值, 并且它还具有自己的scope.有以下几种:</p>
</blockquote>
<ul>
<li>Block(并非真正意义的object, 但却是callable): 在自己所被定义的scope内被求值</li>
<li>Proc: Proc的对象, 和block相同, 在自己所被定义的scope内被求值, return 代表所在是scope的返回值.</li>
<li>Lambdas: 也是Proc的对象, 但是和规则的proc有微妙的区别, 它是闭包, 在自己所被定义的scope内被求值, return代表自己的返回值.</li>
<li>Methods: 绑定到对象上, 在对象的scope被求值, 可以在一个scope中解除绑定, 到另外一个对象或者class上重新绑定.</li>
</ul>
<blockquote>
<p>不同的callable 对象有着细微的差别: 在methods 和 lambdas中, <code>return</code>指的是从callable对象返回, 但是对于procs和blocks来说, <code>return</code>返回的是callable 对象原始的环境(所被定义的scope).<br>不同的callable对象对于参数数量是否准确做出的处理也是不同的, Methods 和 lambdas最为严格, procs和blocks比较宽容一些.<br>callable 对象之间可以互相转换, 比如: <code>Proc.new {}</code>, <code>Method#to_proc</code> 或者<code>&amp;</code>操作符.</p>
</blockquote>
<h2 id="Writing-a-Domain-Specific-Language-特定领域内的语言"><a href="#Writing-a-Domain-Specific-Language-特定领域内的语言" class="headerlink" title="Writing a Domain-Specific Language (特定领域内的语言)"></a>Writing a Domain-Specific Language (特定领域内的语言)</h2><h2 id="Wrap-Up"><a href="#Wrap-Up" class="headerlink" title="Wrap-Up"></a>Wrap-Up</h2><blockquote>
<p>应该掌握的内容:</p>
</blockquote>
<ul>
<li>Scope Gate是什么, Ruby如何管理scope</li>
<li>如何使绑定在scope之间可见, 通过使用Flat Scopes 和 Shared Scopes</li>
<li>如何在对象的scope中执行代码(使用<code>instance_eval</code> 和 <code>instance_exec</code>), 或者在Clean Room中.</li>
<li>block和proc的互相转换</li>
<li>如何将一个方法转换成Method对象或者UnboundMethod对象, 又怎么样转换回来</li>
<li>不同callable 对象之间的不同(blocks, Procs, lambdas, and plain old methods)</li>
<li>如何写DSL语言</li>
</ul>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/24/ruby-metaprogramming-chpt3-methods/" itemprop="url">
                  Ruby 元编程 第三章 方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-24T16:33:43+08:00" content="2015-03-24">
              2015-03-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Ruby/" itemprop="url" rel="index">
                    <span itemprop="name">Ruby</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>不同于Java, C这样的静态语言, Ruby没有编译器, 不会进行拼写检查.比如说在某个对象上调用一个不存在的方法, 直到程序运行到那行错误的调用代码时才会报错.</p>
<p>学习过Java的人可能都知道<code>setter</code>和<code>getter</code>方法, 它们是一种间接访问属性的形式, 一种代理模式, 其本身没有任何意义, 只是为了让编译器可以通过. 而Ruby通过自己的技术手段巧妙避免了这些无聊的方法.本章就来关注这些技术.</p>
</blockquote>
<h2 id="A-Duplication-Problem-重复代码"><a href="#A-Duplication-Problem-重复代码" class="headerlink" title="A Duplication Problem(重复代码)"></a>A Duplication Problem(重复代码)</h2><blockquote>
<p>假设现在需要程序来统计电脑各个部件的信息(价格, 描述…), 返回价格大于99的部件. 首先有个数据源类<code>DS</code>它存储了各个部件的信息, 暂且当作数据库使用.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class DS</span><br><span class="line">  def initialize # connect to data source... </span><br><span class="line">  def get_cpu_info(workstation_id) # ...</span><br><span class="line">  def get_cpu_price(workstation_id) # ...</span><br><span class="line">  def get_mouse_info(workstation_id) # ...</span><br><span class="line">  def get_mouse_price(workstation_id) # ... </span><br><span class="line">  def get_keyboard_info(workstation_id) # ... </span><br><span class="line">  def get_keyboard_price(workstation_id) # ... </span><br><span class="line">  def get_display_info(workstation_id) # ... </span><br><span class="line">  def get_display_price(workstation_id) # ... </span><br><span class="line">  # ...and so on</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>DS#initialize</code>方法会连接到数据系统, 当你创建DS对象的时候, 其他的方法通过接受<code>workstation_id</code>来返回电脑组件的描述以及价格:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># irb</span><br><span class="line">ds = DS.new</span><br><span class="line">ds.get_cpu_info(42) # =&gt; &quot;2.9 Ghz quad-core&quot;</span><br><span class="line">ds.get_cpu_price(42) # =&gt; 120</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接着写Computer类, 返回价格大于99的部件, 需要传入刚才的数据源: </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Computer</span><br><span class="line">  def initialize(computer_id, data_source)</span><br><span class="line">    @id = computer_id</span><br><span class="line">    @data_source = data_source</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def mouse</span><br><span class="line">    info = @data_source.get_mouse_info(@id)</span><br><span class="line">    price = @data_source.get_mouse_price(@id)</span><br><span class="line">    result = &quot;Mouse: #&#123;info&#125; ($#&#123;price&#125;)&quot;</span><br><span class="line">    return &quot;* #&#123;result&#125;&quot; if price &gt;= 100</span><br><span class="line">    result</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def cpu</span><br><span class="line">    info = @data_source.get_cpu_info(@id)</span><br><span class="line">    price = @data_source.get_cpu_price(@id)</span><br><span class="line">    result = &quot;Cpu: #&#123;info&#125; ($#&#123;price&#125;)&quot;</span><br><span class="line">    return &quot;* #&#123;result&#125;&quot; if price &gt;= 100</span><br><span class="line">    result</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def keyboard</span><br><span class="line">    info = @data_source.get_keyboard_info(@id)</span><br><span class="line">    price = @data_source.get_keyboard_price(@id)</span><br><span class="line">    result = &quot;Keyboard: #&#123;info&#125; ($#&#123;price&#125;)&quot;</span><br><span class="line">    return &quot;* #&#123;result&#125;&quot; if price &gt;= 100</span><br><span class="line">    result</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很显然, 这些代码只需要写一个其他的复制粘贴就可以了, 下一节就要研究下如何去掉这些重复的部分</p>
</blockquote>
<h2 id="Dynamic-Methods-动态方法"><a href="#Dynamic-Methods-动态方法" class="headerlink" title="Dynamic Methods(动态方法)"></a>Dynamic Methods(动态方法)</h2><blockquote>
<p>调用方法可以理解为给对象传递一个消息.</p>
</blockquote>
<h3 id="Calling-Methods-Dynamically"><a href="#Calling-Methods-Dynamically" class="headerlink" title="Calling Methods Dynamically"></a>Calling Methods Dynamically</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line">  def my_method(my_arg)</span><br><span class="line">    my_method * 2</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">obj = MyClass.new</span><br><span class="line">obj.my_method(3)   # =&gt; 6</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的例子说明了方法调用其实就是一直<code>.</code>操作符的使用.<br>我们还可以使用<code>Object#send</code>方法来替换掉<code>MyClass#my_method</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.send(:my_method, 3) # =&gt; 6</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>send</code>的第一个参数代表对obj发送的消息, 使用的是Symbol或者String的形式来代表方法名. 剩下的参数(或者block)只是简单地传给了方法.</p>
<p>为什么使用<code>send</code>代替<code>.</code>操作符?<br><strong><em> 因为使用<code>send</code>方法, 你所要调用的方法名变成了一个规则的参数. 在程序运行的时候,你可以等到最后一刻来决定来调用哪一个方法,  这种技术叫做动态派遣(Dynamic Dispatch) </em></strong></p>
<p>这个技术非常实用, 来看看几个真实的案例:</p>
</blockquote>
<h4 id="The-Pry-Example"><a href="#The-Pry-Example" class="headerlink" title="The Pry Example"></a>The Pry Example</h4><blockquote>
<p>pry gem可以作为irb(Ruby的command-line interpreter)的替代品. Pry对象存储了解释器的配置信息, 作为自己的属性, 比如说: <code>memory_size</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">require &quot;pry&quot;</span><br><span class="line"></span><br><span class="line">pry = Pry.new</span><br><span class="line">pry.memory_size = 101</span><br><span class="line">pry.memory_size # =&gt; 101</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于每个实例方法<code>Pry#memory_size</code>都有一个对应的类方法<code>Pry.memory_size</code>, 类方法返回的是默认值:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pry.memory_size # =&gt; 100</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们来深入到Pry的源码, 你可以使用<code>Pry#refresh</code>来配置一个Pry的实例. 该方法接受hash来映射属性名到新的值上:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pry.refresh(:memory_size =&gt; 99, :quiet =&gt; false)</span><br><span class="line">pry.memory_size # =&gt; 99</span><br><span class="line">pry.quiet # =&gt; false</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Pry#refresh</code>有很多工作要做, 首先需要检查每个属性(比如 <code>self.memory_size</code>), 使用默认值初始化属性(比如<code>Pry.memory_size</code>); 最后检查对于同一属性来说, hash参数是否有一个新值, 有, 就设置该新值.<br>刚刚的这段描述如果使用代码来表述, 可能会是这样的:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def refresh(options=&#123;&#125;)</span><br><span class="line">  defaults[:memory_size] = Pry.memory_size</span><br><span class="line">  self.memory_size = options[:memory_size] if options[:memory_size]</span><br><span class="line">  defaults[:quiet] = Pry.quiet</span><br><span class="line">  self.quiet = options[:quiet] if options[:quiet]</span><br><span class="line"></span><br><span class="line">  # same for all the other attributes...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是这样的代码并不简洁, 需要判断很多属性, 这时候使用<code>send</code>方法就会灵活很多了</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def refresh(options)</span><br><span class="line">  default = &#123;&#125;</span><br><span class="line">  attributes = [ :input, :output, :commands, :print, :quiet,</span><br><span class="line">                   :exception_handler, :hooks, :custom_completions,</span><br><span class="line">                   :prompt, :memory_size, :extra_sticky_locals ]</span><br><span class="line">  attributes.each do |attribute|</span><br><span class="line">    defaults[attribute] = Pry.send(attribute)</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  defaults.merge!(options).each do |key, value|</span><br><span class="line">    send(&quot;#&#123;key&#125;=&quot;, value) if respond_to?(&quot;#&#123;key&#125;=&quot;)</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的代码使用<code>send</code>把先把默认值读取到一个hash中(<code>defaults</code>), 然后将这个hash与传入参数options合并, 注意: 使用merge! 方法options会覆盖掉defaults原来的值. 最后又一次使用send方法来调用属性的访问器(赋值)方法, 比如说<code>memory_size=</code>, <code>Kernel#respond_to?</code>方法判断方法是否存在, 如<code>Pry#memory_size=</code>. 所以Pry中不存在的属性就会被忽略.</p>
</blockquote>
<h4 id="Privacy-Matters"><a href="#Privacy-Matters" class="headerlink" title="Privacy Matters"></a>Privacy Matters</h4><blockquote>
<p><code>send</code>方法过于强悍, 以至于私有方法都可以调用. 这样似乎不尊重接收者的隐私, 如果你不想调用这些私有方法, 可以使用<code>public_send</code>代替.</p>
</blockquote>
<h3 id="Defining-Methods-Dynamically-动态地定义方法"><a href="#Defining-Methods-Dynamically-动态地定义方法" class="headerlink" title="Defining Methods Dynamically (动态地定义方法)"></a>Defining Methods Dynamically (动态地定义方法)</h3><blockquote>
<p>刚刚说的<code>send</code>方法可以动态调用方法, 如果要想动态定义一个方法应该使用<code>Module#define_method</code>方法, 你需要提供方法名称的symbol和一个block作为方法体, block的参数作为方法的参数:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line">  define_method :my_method do |my_arg|</span><br><span class="line">    my_arg * 3</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">obj = MyClass.new</span><br><span class="line">obj.new(2)  #=&gt; 6</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>define_method</code>被执行于<code>MyClass</code>中, 所以<code>my_method</code>是实例方法. 这种在运行时定义方法的技术就是动态方法定义.<br>相对于<code>def</code>关键字定义的方法, <code>define_method</code>可以让你在程序运行时决定被定义方法的名称, 具体例子看后面的例子.</p>
</blockquote>
<h3 id="Refactoring-the-Computer-Class"><a href="#Refactoring-the-Computer-Class" class="headerlink" title="Refactoring the Computer Class"></a>Refactoring the Computer Class</h3><blockquote>
<p>回忆之前的Computer 类, 做了很多复制粘贴, 现在已经学过了动态方法定义的知识, 使用<code>define_method</code>来替换掉<code>def</code>关键字:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Computer</span><br><span class="line">  def initialize(computer_id, data_source)</span><br><span class="line">    @id = computer_id</span><br><span class="line">    @data_source = data_source</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def mouse</span><br><span class="line">    info = @data_source.get_mouse_info(@id)</span><br><span class="line">    price = @data_source.get_mouse_price(@id)</span><br><span class="line">    result = &quot;Mouse: #&#123;info&#125; ($#&#123;price&#125;)&quot;</span><br><span class="line">    return &quot;* #&#123;result&#125;&quot; if price &gt;= 100</span><br><span class="line">    result</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def cpu</span><br><span class="line">    info = @data_source.get_cpu_info(@id)</span><br><span class="line">    price = @data_source.get_cpu_price(@id)</span><br><span class="line">    result = &quot;Cpu: #&#123;info&#125; ($#&#123;price&#125;)&quot;</span><br><span class="line">    return &quot;* #&#123;result&#125;&quot; if price &gt;= 100</span><br><span class="line">    result</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def keyboard</span><br><span class="line">    info = @data_source.get_keyboard_info(@id)</span><br><span class="line">    price = @data_source.get_keyboard_price(@id)</span><br><span class="line">    result = &quot;Keyboard: #&#123;info&#125; ($#&#123;price&#125;)&quot;</span><br><span class="line">    return &quot;* #&#123;result&#125;&quot; if price &gt;= 100</span><br><span class="line">    result</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Step-1-Adding-Dynamic-Dispatches-添加动态派遣"><a href="#Step-1-Adding-Dynamic-Dispatches-添加动态派遣" class="headerlink" title="Step 1: Adding Dynamic Dispatches (添加动态派遣)"></a>Step 1: Adding Dynamic Dispatches (添加动态派遣)</h4><blockquote>
<p>不难发现, <code>mouse, cpu, keyboard</code>这几个方法里面的内容结果是相同的, 我们先把重复代码抽取到自己的消息传递方法中:</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(computer_id, data_source)</span></span></span><br><span class="line">    @id = computer_id</span><br><span class="line">    @data_source = data_source</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">mouse</span></span></span><br><span class="line">    component <span class="symbol">:mouse</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">cpu</span></span></span><br><span class="line">    component <span class="symbol">:cpu</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">keyboard</span></span></span><br><span class="line">    component <span class="symbol">:keyboard</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">component</span><span class="params">(name)</span></span></span><br><span class="line">    info = @data_source.send <span class="string">"get_<span class="subst">#&#123;name&#125;</span>_info"</span>, @id</span><br><span class="line">    price = @data_source.send <span class="string">"get_<span class="subst">#&#123;name&#125;</span>_price"</span>, @id</span><br><span class="line">    result = <span class="string">"<span class="subst">#&#123;name.capitalize&#125;</span>: <span class="subst">#&#123;info&#125;</span> ($<span class="subst">#&#123;price&#125;</span>)"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"* <span class="subst">#&#123;result&#125;</span>"</span> <span class="keyword">if</span> price &gt;= <span class="number">100</span></span><br><span class="line">    result</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样重构之后, 所有对于<code>mouse</code>的调用就代理给了<code>component</code>, 在<code>component</code>方法中, 依次调用了<code>DS#get_mouse_info</code> 和 <code>get_mouse_price</code>.</p>
</blockquote>
<h4 id="Step-2-Generating-Methods-Dynamically-动态生成方法"><a href="#Step-2-Generating-Methods-Dynamically-动态生成方法" class="headerlink" title="Step 2: Generating Methods Dynamically (动态生成方法)"></a>Step 2: Generating Methods Dynamically (动态生成方法)</h4><blockquote>
<p>但是还是可以看到相似代码, 那么就要使用<code>define_method</code>来动态生成<code>cpu</code>, <code>keyboard</code>等这些方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Computer </span><br><span class="line">  def initialize(computer_id, data_source)</span><br><span class="line">    @id = computer_id</span><br><span class="line">    @data_source = data_source</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def self.define_component(name)</span><br><span class="line">    define_method(name) do</span><br><span class="line">      info = @data_source.send &quot;get_#&#123;name&#125;_info&quot;, @id</span><br><span class="line">      price = @data_source.send &quot;get_#&#123;name&#125;_price&quot;, @id</span><br><span class="line">      result = &quot;#&#123;name.capitalize&#125;: #&#123;info&#125; ($#&#123;price&#125;)&quot;</span><br><span class="line">      return &quot;* #&#123;result&#125;&quot; if price &gt; 100</span><br><span class="line">      result</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  # 下面的方法省略了self, 并且会在类定义中执行</span><br><span class="line">  define_component :mouse</span><br><span class="line">  define_component :cpu</span><br><span class="line">  define_component :keyboard</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><em> 这里面必须要注意, 3次对于<code>define_component</code>这个方法的调用被执行于Computer这个类的内部, 事实上Computer已经暗示接收者为<code>self</code>, 即: <code>self.define_component :mouse</code>. 由于是在类中调用的方法, 而非方法的定义, 所以我们必须让<code>define_component</code>这个方法为类方法: <code>Computer.define_component</code> </em></strong></p>
</blockquote>
<h4 id="Step-3-Sprinkling-the-Code-with-Introspection-使用内省点缀一下代码"><a href="#Step-3-Sprinkling-the-Code-with-Introspection-使用内省点缀一下代码" class="headerlink" title="Step 3: Sprinkling the Code with Introspection (使用内省点缀一下代码)"></a>Step 3: Sprinkling the Code with Introspection (使用内省点缀一下代码)</h4><blockquote>
<p>我们可以看到还是有重复的代码–调用了3次<code>define_component</code>. 现在就来将其合并</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Computer</span><br><span class="line">  def initialize(computer_id, data_source)</span><br><span class="line">    @id = computer_id</span><br><span class="line">    @data_source = data_source</span><br><span class="line">    data_source.methods.grep(/^get_(.*)_info$/) &#123; Computer.define_component $1 &#125;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">   def self.define_component(name)</span><br><span class="line">     define_method(name) do</span><br><span class="line">       info = @data_source.send &quot;get_#&#123;name&#125;_info&quot;, @id</span><br><span class="line">       price = @data_source.send &quot;get_#&#123;name&#125;_price&quot;, @id</span><br><span class="line">       result = &quot;#&#123;name.capitalize&#125;: #&#123;info&#125; ($#&#123;price&#125;)&quot;</span><br><span class="line">       return &quot;* #&#123;result&#125;&quot; if price &gt; 100</span><br><span class="line">       result</span><br><span class="line">     end</span><br><span class="line">   end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>initialize</code>方法中新添加的代码就是奇迹发生的地方, 以下是对这行代码的理解:</p>
<p>首先如果你将一个block传递给<code>Array#grep</code>这个方法, 每当有一个元素匹配正则表达式, block就会被执行一次. 第二, 正则表达式的<code>(.*)</code>部分被存到了全局变量<code>$1</code>中.<br>所以, 如果<code>data_source</code>有两个方法名为<code>get_cpu_info</code>和<code>get_mouse_info</code>, <code>Computer.define_method $1</code>会被执行2次, $1分别为<code>&quot;cpu&quot;</code>和<code>&quot;mouse&quot;</code></p>
<p>如果DS添加了新的组件, 如<code>get_scanner_info</code>, Computer不需要做任何修改.</p>
</blockquote>
<h3 id="Methods-Names-and-Symbols"><a href="#Methods-Names-and-Symbols" class="headerlink" title="Methods Names and Symbols"></a>Methods Names and Symbols</h3><blockquote>
<p>研究一下Symbol 和 String 有什么区别:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:x.class # =&gt; Symbol</span><br><span class="line">&quot;x&quot;.class # =&gt; String</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然属于不同的类, 但是symbol和string有着很多的相似之处, 你可能会好奇为什么不能使用string代替symbol呢?</p>
</blockquote>
<h4 id="使用symbol的原因"><a href="#使用symbol的原因" class="headerlink" title="使用symbol的原因"></a>使用symbol的原因</h4><blockquote>
<p>大多数情况下, symbol用作事物的名称, 尤其是元编程相关的名称, 比如方法的名称一般使用symbol. 这是由于symbol是不可变的, 但是string的值你是可以改变的, 你定义了一个方法, 它的名字当然是固定的.比如:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.send(:+, 2) #=&gt; 3</span><br><span class="line"># 当然可以使用&quot;x&quot;, 但是使用symbol看起来更加简练</span><br></pre></td></tr></table></figure>
<h4 id="Symbol和String的转换"><a href="#Symbol和String的转换" class="headerlink" title="Symbol和String的转换"></a>Symbol和String的转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;abc&quot; #=&gt; :abc</span><br><span class="line">:abc.to_sa # =? &quot;abc&quot;</span><br></pre></td></tr></table></figure>
<h2 id="method-missing"><a href="#method-missing" class="headerlink" title="method_missing"></a>method_missing</h2><blockquote>
<p>对于<code>Computer</code>的重构还有第二种解决方法: 使用Ghost Methods 和 dynamic proxies.</p>
<p>由于Ruby设计时就是没有编译器的, 所以他不会进行语法检查, 你可以调用不存在的方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Lawyer; end</span><br><span class="line">nick = Lawyer.new</span><br><span class="line">nick.talk_simple</span><br><span class="line"></span><br><span class="line"> NoMethodError: undefined method `talk_simple&apos; for #&lt;Lawyer:0x007f801aa81938&gt;`</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Ruby如果找不到<code>talk_simple</code>这个方法, 就会调用<code>BasicObject</code>的私有方法<code>method_missing</code>. 由于是私有方法, 我们使用send来做个实验:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nick.send(:talk_simple, :my_method)</span><br><span class="line">❮ NoMethodError: undefined method `my_method&apos; for #&lt;Lawyer:0x007f801b0f4978&gt;`</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个方法以抛异常(NoMethodError)的形式处理对象不存在方法的情况.</p>
</blockquote>
<h3 id="Overriding-method-missing-重写method-missing"><a href="#Overriding-method-missing-重写method-missing" class="headerlink" title="Overriding method_missing (重写method_missing)"></a>Overriding method_missing (重写method_missing)</h3><blockquote>
<p>我们都知道发生了异常程序就会中断, 由于<code>method_missing</code>就是抛异常的, 那么我可以通过重写该方法, 覆盖掉<code>BasicObject</code>中定义的这个方法, 避免抛异常, 然后我就可以在重写方法所在类的任意对象上调用不存在的方法了.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Lawyer</span><br><span class="line">  def method_missing(method, *args)</span><br><span class="line">    puts &quot;You called: #&#123;method&#125;(#&#123;args.join(&apos;, &apos;)&#125;)&quot;</span><br><span class="line">    puts &quot;(You also passed it a block)&quot; if block_given?</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">bob = Lawyer.new</span><br><span class="line">bob.talk_simple(&apos;a&apos;, &apos;b&apos;) do</span><br><span class="line">  # block</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">You called: talk_simple(a, b) </span><br><span class="line">(You also passed it a block)</span><br></pre></td></tr></table></figure>
<h3 id="Ghost-Methods-幽灵方法"><a href="#Ghost-Methods-幽灵方法" class="headerlink" title="Ghost Methods (幽灵方法)"></a>Ghost Methods (幽灵方法)</h3><blockquote>
<p>当你需要定义许多相似的方法时, 先不要急着定义, 想想<code>method_missing</code>这个方法, 因为如果方法不存在, 就会把调用请求交给<code>method_missing</code>. 可以通过重写method_missing这个方法来处理本来你想在新方法中定义处理的问题. 好像是在对象说”如果你不知道怎么办(没有定义方法), 做这个(method_missing)”. 这种技巧叫做Ghost Methods. 看下面这个实际的例子:</p>
</blockquote>
<h4 id="The-Hashie-Example"><a href="#The-Hashie-Example" class="headerlink" title="The Hashie Example"></a>The Hashie Example</h4><blockquote>
<p>Hashie gem 有一个很神奇的类<code>Hashie::Mash</code>. Mash是一种类Hash对象, 它的属性很像Ruby的类. 如果你想要一个新的属性, 只需要直接赋值, 这个属性就自动加进去了:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require &apos;hashie&apos;</span><br><span class="line">icecream = Hashie::Mash.new</span><br><span class="line">icecream.flavor = &quot;strawberry&quot;</span><br><span class="line">icecream.flavor # =&gt; &quot;strawberry&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实它内部就重写了这个<code>method_missing</code>方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module Hashie</span><br><span class="line">  class Hash &lt; Hashie::Hash</span><br><span class="line">    def method_missing(method_name, *args, &amp;blk)</span><br><span class="line">      return self.[](method_name, &amp;blk) if key?(method_name)</span><br><span class="line">      match = method_name.to_s.match(/(.*?)([?=!]?)$/)</span><br><span class="line">      case match[2]</span><br><span class="line">      when &quot;=&quot;</span><br><span class="line">        self.[match[1]] = args.first</span><br><span class="line">        # ...</span><br><span class="line">      else</span><br><span class="line">        default(method_name, *args, &amp;blk)</span><br><span class="line">      end</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="Dynamic-Proxies-动态代理"><a href="#Dynamic-Proxies-动态代理" class="headerlink" title="Dynamic Proxies (动态代理)"></a>Dynamic Proxies (动态代理)</h3><blockquote>
<p>我们不可能在每一个类中重写<code>method_missing</code>方法, 我们可以将这个方法重写到一个类中, 然后让需要<code>method_missing</code>这个方法的类来继承这个类, 这个类就是代理类. 拿Ghee这个gem来举例:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Ghee</span><br><span class="line">  class ResourceProxy</span><br><span class="line">    def method_missing(message, *args, &amp;block)</span><br><span class="line">      subject.send(message, *args, &amp;block)</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    def subject</span><br><span class="line">      @subject ||= connection.get(path_prefix)&#123;|req| req.params.merge!params &#125;.body</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">class Ghee</span><br><span class="line">  module API</span><br><span class="line">    module Gists</span><br><span class="line">      class Proxy &lt; ::Ghee::ResourceProxy</span><br><span class="line">        def star</span><br><span class="line">          connection.put(&quot;#&#123;path_prefix&#125;/star&quot;).status == 204</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        # ... some other methods</span><br><span class="line">      end</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当你调用<code>Ghee::API::Gists#star</code>方法时, 由于它存在, 会正常执行, 但是假如你调用<code>Ghee::API::Gists#description</code>, 由于不存在, Ruby会直接到<code>::Ghee::ResourceProxy</code>和祖先链中寻找,都没有发现, 而<code>::Ghee::ResourceProxy</code>中重写了method_missing,  就会执行该方法, 这个方法中, 又把调用转给了<code>subject</code>方法返回的对象. </p>
<p>简单理解, 代理类就是一个方法调用的收集器.</p>
</blockquote>
<h3 id="Refactoring-the-Computer-Class-Again-再次重构Computer"><a href="#Refactoring-the-Computer-Class-Again-再次重构Computer" class="headerlink" title="Refactoring the Computer Class (Again) (再次重构Computer)"></a>Refactoring the Computer Class (Again) (再次重构Computer)</h3><blockquote>
<p>Computer是一个收集调用的包装, 把这些调用拧到一起, 再来调用data_source上相应的方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Computer</span><br><span class="line">  def initialize(computer_id, data_source)</span><br><span class="line">    @id = computer_id</span><br><span class="line">    @data_source = data_source</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def method_missing(name)</span><br><span class="line">    super unless @data_source.respond_to(&quot;get_#&#123;name&#125;_info&quot;)</span><br><span class="line">    info = @data_source.send(&quot;get_#&#123;name&#125;_info&quot;, @id)</span><br><span class="line">    price = @data_source.send(&quot;get_#&#123;name&#125;_price&quot;)</span><br><span class="line">    result = &quot;#&#123;name.capitalize&#125;: #&#123;info&#125; ($#&#123;price&#125;)&quot;</span><br><span class="line">    return &quot;* #&#123;result&#125;&quot; if price &gt;= 100</span><br><span class="line">    result</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="respond-to-missing"><a href="#respond-to-missing" class="headerlink" title="respond_to_missing?"></a>respond_to_missing?</h3><blockquote>
<p>如果你问<code>Computer</code>是否可以响应Ghost Method, 它的回答是不可以:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp = Computer.new(0, DS.new)</span><br><span class="line">cmp.respond_to?(:mouse) # =&gt; false</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是个严重的问题, 我们经常会使用<code>respond_to?</code>判断对象是否包含某个方法, 幸运的是, Ruby为我们提供了简单的方法让<code>respond_to?</code>可以响应Ghost Methods. 如果一个方法是Ghost Method, <code>respond_to?</code>会去调用一个叫做<code>respond_to_missing?</code>的方法, 所以现在需要做的是重写<code>respond_to_missing?</code>方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Computer</span><br><span class="line">  [...]</span><br><span class="line">  def respond_to_missing?(method, include_private = false)</span><br><span class="line">    @data_source.respond_to?(&quot;get_#&#123;method&#125;_info&quot;) || super</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码和<code>method_missing</code>的第一行很相似, 它先看这个方法是不是Ghost, 是, 返回true, 不是调用super, 这里super调用的是<code>Object#respond_to_missing?</code>, 它一直返回false.<br>这时候<code>respond_to?</code>就会认识Ghost Method了:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp.respond_to?(:mouse) #=&gt; true</span><br></pre></td></tr></table></figure>
<h2 id="const-missing"><a href="#const-missing" class="headerlink" title="const_missing"></a>const_missing</h2><blockquote>
<p>之前学习的是<code>method_missing</code>, 它接受方法名, 来处理Ghost Methods. 这里的<code>const_missing</code>可以理解为接收常量, 来处理”Ghost Constants”(这个名字是我起的, 不知道存在不)</p>
<p>还记得之前说过关于Rake版本升级的问题吗? Rake重命名了一些类为了避免冲突, 但是需要对于几个版本来说用户可以自由选择使用新的名字还是之前的名字, Rake就是使用<code>Module#const_missing</code>方法实现的:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Module</span><br><span class="line">  def const_missing(const_name)</span><br><span class="line">    case const_name</span><br><span class="line">    when :Task</span><br><span class="line">      Rake.application.const_warning(const_name)</span><br><span class="line">      Rake::Task</span><br><span class="line">    when :FileTask</span><br><span class="line">      Rake.application.const_warning(const_name)</span><br><span class="line">      Rake::FileTask</span><br><span class="line">    when :FileCreationTaks</span><br><span class="line">      # ...</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当你引用了一个不再使用(不存在)的常量, Ruby会把常量的名字以symbol的形式传给<code>const_missing</code>方法, 又因为<code>Class names</code>也是常量, 引用到了一个未知Rake class比如说”Rake”, 就会交给<code>Module#const_missing</code>处理:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">require</span><br><span class="line">task_class = Task</span><br><span class="line"></span><br><span class="line"># =&gt; </span><br><span class="line">WARNING: Deprecated reference to top-level constant &apos;Task&apos; found [...]</span><br><span class="line">Use --classic-namespace on rake command</span><br><span class="line">or &apos;require &quot;rake/classic_namespace&quot;&apos; in Rakefile</span><br></pre></td></tr></table></figure>
<blockquote>
<p>返回新的Rake 名:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task_class # =&gt; Rake::Task</span><br></pre></td></tr></table></figure>
<h3 id="关于method-missing的错误提示"><a href="#关于method-missing的错误提示" class="headerlink" title="关于method_missing的错误提示"></a>关于<code>method_missing</code>的错误提示</h3><blockquote>
<p>需要格外小心的一点是<code>method_missing</code>方法中很可能出现这样的bug: 你使用了一个没有定义的方法, 又一次触发了<code>method_missing</code>的调用, 导致发生了递归调用:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Roulette</span><br><span class="line"></span><br><span class="line">  def method_missing(name, *args)</span><br><span class="line">    person = name.to_s.capitalize</span><br><span class="line">    3.times do</span><br><span class="line">      number = rand(10) + 1</span><br><span class="line">      puts &quot;#&#123;number&#125;...&quot;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    &quot;&#123;person&#125; got a #&#123;number&#125;&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">number_of = Roulette.new</span><br><span class="line">puts number_of.bob</span><br></pre></td></tr></table></figure>
<blockquote>
<p>发生<code>method_missing</code>不断被调用的递归错误:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2...</span><br><span class="line">7... </span><br><span class="line">1... </span><br><span class="line">5...</span><br><span class="line">(...more numbers here...)</span><br><span class="line"> roulette_failure.rb:7:in `method_missing&apos;: stack level too deep (SystemStackError)</span><br><span class="line">    `</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原因在于: <code>number</code>在block中被定义, 在block外部被调用触发了<code>method_missing</code>的调用, 方法中调用了本方法, 发生了无限递归. 所以需要将<code>number</code>的定义从block中提取出来:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Roulette</span><br><span class="line">  def method_missing(name, *args)</span><br><span class="line">    person = name.to_s.capitalize</span><br><span class="line">    # 不要引入太多的Ghost Methods</span><br><span class="line">    super unless %w(Bob Frank Bill).include? person</span><br><span class="line">    number = 0</span><br><span class="line">    3.times do</span><br><span class="line">      number = rand(10) + 1</span><br><span class="line">      puts &quot;#&#123;number&#125;...&quot;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    &quot;#&#123;person&#125; got A #&#123;number&#125;&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">number_of = Roulette.new</span><br><span class="line">puts number_of.Bob</span><br></pre></td></tr></table></figure>
<h2 id="Blank-Slates-一片空白"><a href="#Blank-Slates-一片空白" class="headerlink" title="Blank Slates (一片空白)"></a>Blank Slates (一片空白)</h2><blockquote>
<p>当Ghost 方法和 实际存在的方法重名时, Ruby会优先选择实际存在的方法调用. 比如 Computer有一个<code>display</code>的Ghost方法, 它是由<code>method_missing</code>代理产生的. 而Object有一个实际存在的<code>display</code>方法, 那么Ruby会优先选择Object的<code>display</code>方法. 原因是Ruby中方法调用的查找顺序, 在Object上找到<code>display</code>后, <code>method_missing</code>永远不会被执行到.</p>
</blockquote>
<h3 id="BasicObject"><a href="#BasicObject" class="headerlink" title="BasicObject"></a>BasicObject</h3><blockquote>
<p>Ruby继承关系的根类—BasicObject, 仅有几个必要的实例方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">im = BasicObject.instance_methods</span><br><span class="line">im # =&gt; [:==, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所以上面的问题有了解决的办法, 可以直接让Computer继承BasicObject :</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Computer &lt; BasicObject</span><br></pre></td></tr></table></figure>
<blockquote>
<p>事实上Ruby为我们提供了方法来移除一些对象不想继承的方法:</p>
</blockquote>
<ul>
<li><code>undef_method</code>移除的任何方法包含了被继承的方法</li>
<li><code>remove_method</code>从接收者中移除方法, 保留被继承的方法</li>
</ul>
<blockquote>
<p>看下面例子:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Parent</span><br><span class="line">  def hello</span><br><span class="line">    puts &quot;In Parent&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">class Child &lt; Parent</span><br><span class="line">  def hello</span><br><span class="line">    puts &quot;In Child&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">c = Child.new</span><br><span class="line">c.hello</span><br><span class="line"></span><br><span class="line">class Child</span><br><span class="line">  remove_method :hello #  remove from child, still in parent</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">c.hello</span><br><span class="line"></span><br><span class="line">class Child</span><br><span class="line">  undef_method :hello</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">c.hello</span><br></pre></td></tr></table></figure>
<blockquote>
<p>produces:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In Child</span><br><span class="line">In Parent</span><br><span class="line">remove_method.rb:26:in `&lt;main&gt;&apos;: undefined method `hello&apos; for #&lt;Child:0x007febc688be40&gt; (NoMethodError)`&apos;`</span><br></pre></td></tr></table></figure>
<h4 id="The-Builder-Example"><a href="#The-Builder-Example" class="headerlink" title="The Builder Example"></a>The Builder Example</h4><blockquote>
<p> Builder gem 可以方便地生成XML:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">require &apos;builder&apos;</span><br><span class="line">xml = Builder::XmlMarkup.new(:target=&gt;STDOUT, :indent=&gt;2)</span><br><span class="line">xml.coder &#123;</span><br><span class="line">xml.name &apos;Matsumoto&apos;, :nickname =&gt; &apos;Matz&apos; </span><br><span class="line">xml.language &apos;Ruby&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>生成:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;coder&gt;</span><br><span class="line">  &lt;name nickname=&quot;Matz&quot;&gt;Matsumoto&lt;/name&gt;</span><br><span class="line">  &lt;language&gt;Ruby&lt;/language&gt;</span><br><span class="line">&lt;coder/&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Builder会分析Ruby的语法, 生成相应的XML, 它支持嵌套标签, 属性和其他一些细节. Builder的核心就是使用了<code>XmlMarkup#method_missing</code>, 对于每一次调用都生成了XML标签. 比如想要得到下面的XML:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;semester&gt;</span><br><span class="line">  &lt;class&gt;Egyptology&lt;/class&gt; </span><br><span class="line">  &lt;class&gt;Ornithology&lt;/class&gt;</span><br><span class="line">&lt;/semester&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>那么Ruby程序必须是这样的:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xml.semester &#123;</span><br><span class="line">  xml.class &apos;Egyptology&apos;</span><br><span class="line">  xml.class &apos;Ornithology&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般来讲 <code>xml.class</code>应该得到的是<code>Builder::XmlMarkup</code>, 也就是说xml的class 和 Object的class冲突了, 为了避免冲突, XmlMarkup继承了一个BlankSlate, 这个类去掉了Object’s class和其他大多数来自于Object的方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class BlankSlate</span><br><span class="line">  def self.hide(name)</span><br><span class="line">    if instance_methods.include?(name._blankslate_as_name) &amp;&amp;</span><br><span class="line">      name !~ /^(__|instance_eval$)/</span><br><span class="line">      undef_method name # 包含了`class`方法</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="Fixing-the-Computer-Class"><a href="#Fixing-the-Computer-Class" class="headerlink" title="Fixing the Computer Class"></a>Fixing the Computer Class</h3><blockquote>
<p>所以对于<code>display</code>方法的冲突是让Computer继承BasicObject:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Computer &lt; BasicObject</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于BasicObject没有<code>display</code>方法, 所以现在在Computer的对象上调用<code>display</code>就会执行<code>method_missing</code>这个Ghost方法了.<br>现在可以删掉Computer中定义的 <code>respond_to_missing?</code>方法了, 因为BasicObject没有<code>respond_to?</code>方法. 到此为止, 就完成了基于<code>method_missing</code>的Computer了.</p>
</blockquote>
<h2 id="Wrap-Up-总结"><a href="#Wrap-Up-总结" class="headerlink" title="Wrap-Up 总结"></a>Wrap-Up 总结</h2><blockquote>
<p>让我们再看看这两种重构Computer的代码:</p>
</blockquote>
<ul>
<li><p>基于Dynamic Methods 和 Dynamic Dispatch:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Computer</span><br><span class="line">  def initialize(computer_id, data_source)</span><br><span class="line">    @id = computer_id</span><br><span class="line">    @data_source = data_source</span><br><span class="line">    data_source.methods.grep(/^get_#(.*?)_info$/) &#123; Computer.define_component($1) &#125; </span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def self.define_component(name)</span><br><span class="line">    define_method(name) do</span><br><span class="line">      info = @data_source.send &quot;get_#&#123;name&#125;_info&quot;, @id</span><br><span class="line">      price = @data_source.send &quot;get_#&#123;name&#125;_price&quot;, @id</span><br><span class="line">      result = &quot;#&#123;name.capitalize&#125;: #&#123;info&#125; ($#&#123;price&#125;)&quot;</span><br><span class="line">      return &quot;* #&#123;result&#125;&quot; if price &gt;= 100</span><br><span class="line">      result</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于Ghost Methods(Dynamic Proxy) + BlankSlate , 比上面一种更加简洁:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Computer &lt; BasicObject</span><br><span class="line">  def initialize(computer_id, data_source)</span><br><span class="line">    @id = computer_id</span><br><span class="line">    @data_source = data_source</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def method_missing(name, *args)</span><br><span class="line">    super unless @data_source.respond_to?(&quot;get_#&#123;name&#125;_info&quot;)</span><br><span class="line">    info = @data_source.send &quot;get_#&#123;name&#125;_info&quot;, @id</span><br><span class="line">    price = @data_source.send &quot;get_#&#123;name&#125;_price&quot;, @id</span><br><span class="line">    result = &quot;#&#123;name.capitalize&#125;: #&#123;info&#125; ($#&#123;price&#125;)&quot;</span><br><span class="line">    return &quot;* #&#123;result&#125;&quot; if price &gt; 100</span><br><span class="line">    result</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Dynamic-Methods-v-s-Ghost-Methods"><a href="#Dynamic-Methods-v-s-Ghost-Methods" class="headerlink" title="Dynamic Methods v.s. Ghost Methods"></a>Dynamic Methods v.s. Ghost Methods</h3><blockquote>
<p>如果Ruby没有这种动态的能力这两种方法都无法使用. 具体应该使用哪种方法呢?</p>
<p>Ghost方法有一定的危险性, 但是你可以通过调用<code>super</code>, 重新定义<code>respond_to_missing?</code>来避免. 出现这些问题的根本原因是它不是真正的方法, 而是一种拦截方法调用的方式, 所以它和实际的方法表现迥异, 比如: 不会出现在<code>Object</code>的方法列表中.<br>与此相反, Dynamic 方法就是实际的方法了, 它通过使用<code>define_method</code>代替<code>def</code>关键字来定义的方法, 和普通方法没什么不同.<br>有些情况下只能选择Ghost方法. 比如, 你需要进行大量的方法调用或者不清楚在运行时你需要什么方法调用.例如, Builder gem就不能使用Dynamic 方法, 很可能会出现无数的XML标签, 所以使用了<code>method_missing</code>拦截了方法调用.<br>如何在两者之间取舍呢? 一般来说取决于你的经验和代码风格, 但是有下面的原则可以作参考: 能使用Dynamic方法尽量使用, 实在没辙了, 再使用Ghost方法.</p>
</blockquote>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/22/ruby-metaprogramming-chpt2/" itemprop="url">
                  Ruby 元编程 第二章 对象模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-22T12:01:35+08:00" content="2015-03-22">
              2015-03-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Ruby/" itemprop="url" rel="index">
                    <span itemprop="name">Ruby</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Ruby语言中到处是对象这个东西还包含一种编程语言的其他结构, 如<code>class</code>, <code>module</code>和<code>instance variable</code>. 元编程操作的就是这些东西.</p>
<p>首先需要清楚一个概念: 系统中的所有这些结构被称作是<code>object model</code>. 要是弄清楚了<code>object model</code>你就会找到很多问题的答案, 比如, 某个方法是来自于哪个类? 当我include一个module时发生了什么?<br>object model 就是ruby的核心, 掌握了它就掌握了ruby中很强大的技术, 同时也可以帮你避免很多陷阱.</p>
</blockquote>
<h2 id="Open-Classes-打开类"><a href="#Open-Classes-打开类" class="headerlink" title="Open Classes (打开类)"></a>Open Classes (打开类)</h2><blockquote>
<p>在解释<code>Open Classes</code> 之前, 先看一个例子, 下面的方法的作用是去掉字符串所有的符号和空白:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># object_model/alphanumeric.rb</span><br><span class="line">def to_alphanumeric(s) </span><br><span class="line">  s.gsub(/[^\w\s]/, &apos;&apos;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是这个方法并不十分面向对象, 为什么不可以把这个方法给String类呢? 其实Ruby的设计者早就为我们想好了, Ruby允许你打开这个类, 为其添加方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class String</span><br><span class="line">  def to_alphanumeric</span><br><span class="line">    s.gsub(/[^\w\s]/, &apos;&apos;)</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样我就可以这样直接调用: <code>&quot;some_str&quot;.to_alphanumeric</code></p>
</blockquote>
<h3 id="Inside-Class-Definitions-类定义的内部"><a href="#Inside-Class-Definitions-类定义的内部" class="headerlink" title="Inside Class Definitions (类定义的内部)"></a>Inside Class Definitions (类定义的内部)</h3><blockquote>
<p>在Ruby中定义class的代码和其他代码是没有区别的:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3.times do</span><br><span class="line">  class C</span><br><span class="line">    puts &quot;Hello&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># =&gt;</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Ruby在类中执行代码, 和在别的地方无异, 是不是定义了3次<code>class C</code>呢? 其实不是, 可以通过下面的小例子来鉴别:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class D</span><br><span class="line">  def x; &apos;x&apos;; end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">class D</span><br><span class="line">  def y; &apos;y&apos;; end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">obj = D.new</span><br><span class="line"></span><br><span class="line">obj.x # =&gt; &quot;x&quot;</span><br><span class="line">obj.y # =&gt; &quot;y&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一次正常定义<code>class D</code>, 因为这时候并没有定义<code>class D</code>, 而第二次Ruby发现<code>class D</code>已经被定义, 就会打开这个已经存在的D, 在里面定义一个y方法.<br>从某种意义上来讲, Ruby中的<code>class</code>关键字更像是一个域操作符而非类声明.<br>你甚至于可以打开Ruby标准库中的类比如<code>String</code>, <code>Array</code>. 来看看实际中, 这种技巧是如何使用的吧:</p>
</blockquote>
<h4 id="The-Money-Example"><a href="#The-Money-Example" class="headerlink" title="The Money Example"></a>The Money Example</h4><blockquote>
<p>下面的例子介绍了如何把把一个<code>money</code>gem的方法扩展到Ruby的标准库<code>Numeric</code>中.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">require &quot;money&quot;</span><br><span class="line"></span><br><span class="line">class Numeric</span><br><span class="line">  def to_money(currency = nil)</span><br><span class="line">    Money.from_numeric(self, currency || Money.default_currency)</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="The-Problem-with-Open-Classes-Open-Classes可能出现的问题"><a href="#The-Problem-with-Open-Classes-Open-Classes可能出现的问题" class="headerlink" title="The Problem with Open Classes (Open Classes可能出现的问题)"></a>The Problem with Open Classes (Open Classes可能出现的问题)</h4><blockquote>
<p>需要注意: 我们新添加的方法, 如果如果要是与类中的方法同名, 那么新方法就会覆盖掉原来的方法, 所以, 要么确信自己的方法需要兼容原来的方法, 要么就另外起一个方法名.</p>
</blockquote>
<h5 id="查看实例方法集合"><a href="#查看实例方法集合" class="headerlink" title="查看实例方法集合"></a>查看实例方法集合</h5><blockquote>
<p>在扩展一个class之前需要查看类的实例所有方法集合, 从而决定如何为方法命名避免冲突, 这里有个技巧, 比如要查看数组的实例是否有<code>replace</code>方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[].methods.grep /^re/ # =&gt; [:reverse_each, :reverse, ..., :replace, ...]</span><br><span class="line"></span><br><span class="line"># or</span><br><span class="line">Array.instance_methods.grep /^re/ # =&gt; [:reverse_each, :reverse, ..., :replace, ...]</span><br></pre></td></tr></table></figure>
<h2 id="Inside-the-Object-Model-Object-Model的内部"><a href="#Inside-the-Object-Model-Object-Model的内部" class="headerlink" title="Inside the Object Model (Object Model的内部)"></a>Inside the Object Model (Object Model的内部)</h2><blockquote>
<p>在Object Model中可以可以了解到<code>objects</code>, <code>classes</code> <code>constants</code>的原理. 除了<code>Open Classes</code>, 还有更多的东西有待于研究.</p>
</blockquote>
<h3 id="What’s-in-an-Object"><a href="#What’s-in-an-Object" class="headerlink" title="What’s in an Object"></a>What’s in an Object</h3><blockquote>
<p>看下面的代码:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyClass </span><br><span class="line">  def my_method</span><br><span class="line">    @v = 1</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">obj = MyClass.new</span><br><span class="line"></span><br><span class="line">obj.class</span><br><span class="line"># =&gt; MyClass</span><br></pre></td></tr></table></figure>
<blockquote>
<p>打开Ruby的解释器, 看看<code>obj</code>这个对象内部, 研究一下到底里面有什么:</p>
</blockquote>
<h4 id="Instance-Variables-实例变量"><a href="#Instance-Variables-实例变量" class="headerlink" title="Instance Variables (实例变量)"></a>Instance Variables (实例变量)</h4><blockquote>
<p>我可以通过<code>Object#instance_variables</code>方法来获取这些实例变量:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.my_method </span><br><span class="line">obj.instance_variables # =&gt; [:@v]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意在获取实例变量<code>[:@v]</code>之前, 对象<code>obj</code>首先调用了<code>my_method</code>, 这不同于Java等其他静态语言, Ruby中一个对象的类和它的实例变量直接是没有连接的, 只有在为实例变量赋值时, 对象才有这个变量, 你可以把实例变量的名字和值想象成hash的key和value. 如果没有调用<code>my_method</code>方法, 那么obj将永远不会有<code>@v</code>这个实例变量.</p>
</blockquote>
<h4 id="Methods-方法"><a href="#Methods-方法" class="headerlink" title="Methods (方法)"></a>Methods (方法)</h4><blockquote>
<p>对象除了有实力变量以外还有方法. 可以使用<code>Object#methods</code>获取这些方法. 大多数的对象都会从父类<code>Object</code>继承一些方法. 所以这些方法的集合会有很多方法, 可以使用上一节的例子中的<code>grep</code>方法来过滤掉不想要的.<br>如果”劈开”Ruby的解释器观察<code>obj</code>你会发现这个对象没有真正的持有所有这些方法. 它包含一个实例变量<code>@v</code>和一个类的引用. 但是没有方法, 那么方法去了哪里?</p>
<p>看这张示意图:<br><img src="http://i3.tietuku.com/1b1dc3bde3454359.png"></p>
<p>实力变量存储于对象内部, 而方法则在类的内部:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String.instance_methods == &quot;abc&quot;.methods # =&gt; true </span><br><span class="line">String.methods == &quot;abc&quot;.methods # =&gt; false</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于类来说 <code>methods</code>和<code>instance_methods</code>是两码事.</p>
</blockquote>
<h3 id="The-Truth-About-Classes"><a href="#The-Truth-About-Classes" class="headerlink" title="The Truth About Classes"></a>The Truth About Classes</h3><blockquote>
<p>classes什么都不是, 但是objects却很重要. 因为class本身就是object, 适用于object的也适用于class. class和object一样, 有它自己的class:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;hellw&quot;.class # =&gt; String</span><br><span class="line">String.class # =&gt; Class</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其他语言如Java中, Class的实例仅仅是一个class的只读描述, 而在Ruby中, 你可以在程序运行时来修改这些描述. 比如之前的Open Classes<br>像其他对象一样, Class的对象class也是有方法的. object的<code>methods</code> 也是其class的<code>instance_methods</code> :</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># The &quot;false&quot; argument here means: ignore inherited methods</span><br><span class="line">Class.instance_methods(false) # =&gt; [:allocate, :new, :superclass]</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>allocate</code>方法是在我们<code>new</code>对象的时候被Class对象来调用用以分配一块内存.<br>另外, <code>superclass</code>方法可以获取某个Class对象(如: Array, String)的父类:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.superclass # =&gt; Object</span><br><span class="line">Object.superclass # =&gt; BasicObject</span><br><span class="line">BasicObject.superclass # =&gt; nil</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看出继承关系是: Array &lt; Object &lt; BasicObject, BasicObject是Ruby继承树的根.</p>
</blockquote>
<h4 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h4><blockquote>
<p>来看看Class的父类是什么:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.superclass # =&gt; Module</span><br></pre></td></tr></table></figure>
<blockquote>
<p>是Module, 同理, 每个class也是一个module, 严格来讲, <code>class</code>是<code>module</code> 在加上3个方法(new, allocate, and superclass). 允许你创建对象, 或者把类放进分类树中.<br>可见, class和module太像了, 那么怎么准确的使用它们呢? </p>
<ul>
<li>module用于组织代码结构, 你可以把一段代码包含进另外一段的时候使用module</li>
<li>当你要继承或者实例化的时候使用class, 因为它有这几个额外的方法.</li>
</ul>
</blockquote>
<h4 id="Putting-It-All-Together"><a href="#Putting-It-All-Together" class="headerlink" title="Putting It All Together"></a>Putting It All Together</h4><blockquote>
<p>看这段代码:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class MyClass; end</span><br><span class="line">obj1 = MyClass.new</span><br><span class="line">obj2 = MyClass.new</span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="http://i3.tietuku.com/bf32a0d194bd8cac.png"></p>
<p>这张图反映了上述继承关系, Class和通常对象相处的十分融洽.<br>我还可以使用一个变量引用一个类:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_class = MyClass</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这行代码的含义是<code>MyClass</code>和<code>my_class</code>都指向了<code>Class</code>的同一个实例, 唯一的不同是<code>my_class</code>是一个变量而<code>MyClass</code>是一个常量. 也就是说: <strong><em> class仅仅是object, class name仅仅是常量</em></strong></p>
</blockquote>
<h4 id="Constants-常量"><a href="#Constants-常量" class="headerlink" title="Constants (常量)"></a>Constants (常量)</h4><blockquote>
<p>任何一个以大写字母开头, 包括类名和module名在内都可以被叫做常量(constants).<br>module把里面的class或者module以类似于文件系统的树状结构组织起来的:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module MyModule</span><br><span class="line">  MyConstant = &apos;Outer constant&apos;</span><br><span class="line"></span><br><span class="line">  class MyClass</span><br><span class="line">    MyConstant = &apos;Inner constant&apos;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>MyModule的MyConstant和MyClass的MyConstant是不同的, 它们属于不同的scope:<br><img src="http://i3.tietuku.com/bfab05bdfdede2c6.png"></p>
</blockquote>
<h5 id="The-Paths-of-Constants-常量的获取路径"><a href="#The-Paths-of-Constants-常量的获取路径" class="headerlink" title="The Paths of Constants 常量的获取路径"></a>The Paths of Constants 常量的获取路径</h5><blockquote>
<p>别忘记一点, module中的类其实也是常量. 刚刚说过, 常量像是嵌套的目录和文件, 那么一定有一种方法来定位这些路径和文件. Ruby使用双冒号来定位它们, 可以将其理解为每一个<code>::</code>相当于文件系统的<code>/</code>(Linux).</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module M</span><br><span class="line">  class C</span><br><span class="line">    X = &apos;a constant&apos;</span><br><span class="line">  end</span><br><span class="line">  C::X # =&gt; &quot;a constant&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">M::C::X # =&gt; &quot;a constant&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果在一个很深的目录, 可以使用以<code>::</code>开头的形式获取根路径的绝对路径:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Y = &apos;a root-level constant&apos;</span><br><span class="line"></span><br><span class="line">module M</span><br><span class="line">  Y = &apos;a const in M&apos;</span><br><span class="line">  puts Y # =&gt; &quot;a constant in M&quot;</span><br><span class="line">  puts ::Y # =&gt;  &apos;a root-level constant&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Module 类还提供了实例方法和类方法来获取常量, 有点让人困惑的是都叫做<code>constants</code>. 实例方法<code>Module#constants</code>在当前scope中返回所有的常量, 类似于文件系统的<code>ls</code>命令. 类方法<code>Module.constants</code>返回程序中所有的top-level的常量, 注意包含类名:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">M.constants # =&gt; [:C, :Y]</span><br><span class="line">Module.constants.include? :Object # =&gt; true</span><br><span class="line">Module.constants.include? :Module # =&gt; true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyD</span><br><span class="line">  class MyC</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">Module.constants.include? :MyD #=&gt; true</span><br><span class="line">Module.constants.include? :MyC #=&gt; false</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Module.nesting</code>获取当前的路径:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module M</span><br><span class="line">  class C</span><br><span class="line">    module M2 </span><br><span class="line">      Module.nesting # =&gt; [M::C::M2, M::C, M]</span><br><span class="line">    end </span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h5 id="The-Rake-Example"><a href="#The-Rake-Example" class="headerlink" title="The Rake Example"></a>The Rake Example</h5><blockquote>
<p>不管module也好, class也好, 它们声明的都是常量, 在最早的Rake中, 直接就使用了class来声明Task 和 FileTask, 这样就很容易发生命名冲突,  后来就在外面套了一层module:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module Rake</span><br><span class="line">  class Task</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样就避免了发生冲突, 如果想要使用Task类需要这样定位<code>Rake::Task</code>, 像<code>Rake</code>这样的module, 存在的意义仅仅是常量的容器, 就把它称作命名空间(Namespace).<br>但是这样就出现了一个问题, 一些程序员的机器还在使用旧的版本的<code>rake</code>, 没有Rake这个命名空间, 所以Rake的作者给出的解决方案是提供命令行选项<code>classic-namespace</code>来加载一个ruby的源文件, 这个源文件吧新的更安全的常量名称赋给旧的不安全的:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># gems/rake-0.9.2.2/lib/rake/classic_namespace.rb</span><br><span class="line">Task = Rake::Task</span><br><span class="line">FileTask = Rake::FileTask </span><br><span class="line">FileCreationTask = Rake::FileCreationTask # ...</span><br></pre></td></tr></table></figure>
<h3 id="Objects-and-Classes-Wrap-up-对象和类的小结"><a href="#Objects-and-Classes-Wrap-up-对象和类的小结" class="headerlink" title="Objects and Classes Wrap-up (对象和类的小结)"></a>Objects and Classes Wrap-up (对象和类的小结)</h3><blockquote>
<p>什么是object? 它就是一堆实例变量, 加上一个到class的链接. object的方法并不在object中, 而是在object的class中, 而在class中这些方法又被叫做instance 方法.<br>什么是class? 它是object(Class的实例), 加上一列实例方法和一个到父类的链接. <code>Class</code>是<code>Module</code>的子类, 所以<code>class</code>也是<code>module</code><br>和其他的object一样, <code>class</code>也有它自己的方法, 比如说<code>new</code>, 像其他object一样, <code>class</code>也要通过引用来访问, 这个引用就是class的名字, 它是一个常量(constant)</p>
</blockquote>
<h4 id="Loading-and-Requiring"><a href="#Loading-and-Requiring" class="headerlink" title="Loading and Requiring"></a>Loading and Requiring</h4><h5 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a>load方法</h5><blockquote>
<p>如果要加载<code>motd.rb</code>这个文件你可能会这样写:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load(&apos;motd.rb&apos;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样会引起一个问题, 加入<code>motd.rb</code>这样文件中存在class和variable, 变量在文件加载完毕后会消失, 但是文机制的类名(常量, 目录)可能会污染程序的结构. 那么添加一个参数<code>true</code>就会避免这种情况:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load(&apos;motd.rb&apos;, true)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Ruby会创建一个匿名的module来包裹<code>motd.rb</code>定义的所有常量, 起到命名空间的作用, 执行完后再删除这个module. </p>
</blockquote>
<h5 id="require-方法"><a href="#require-方法" class="headerlink" title="require 方法"></a>require 方法</h5><blockquote>
<p>require和load很相似, 但是, 它们的目的不同, <code>load</code>是用来导入执行的代码, 而<code>require</code>用来引入库.</p>
</blockquote>
<h2 id="What-Happens-When-You-Call-a-Method-当你调用一个方法时-发生了什么"><a href="#What-Happens-When-You-Call-a-Method-当你调用一个方法时-发生了什么" class="headerlink" title="What Happens When You Call a Method? (当你调用一个方法时, 发生了什么?)"></a>What Happens When You Call a Method? (当你调用一个方法时, 发生了什么?)</h2><blockquote>
<p>当你在调用一个方法的时候, Ruby做了两件事情:</p>
</blockquote>
<ul>
<li>它找到方法, 这个过程被叫做方法查找(method lookup)</li>
<li>它执行方法, Ruby需要调用自己<code>self.</code></li>
</ul>
<blockquote>
<p>这两个步骤在面向对象的语言中是必须要做的. 首先来看看方法查找(method lookup)</p>
</blockquote>
<h3 id="Method-Lookup-方法查找"><a href="#Method-Lookup-方法查找" class="headerlink" title="Method Lookup (方法查找)"></a>Method Lookup (方法查找)</h3><blockquote>
<p>当你在一个对象上调用方法时, Ruby会窥视该对象查找调用的方法.<br>我们先来弄清楚2个概念: <code>receiver</code>和<code>ancestors chain</code>: 即接收者和祖先调用链:</p>
<p>receiver 就是你所调用方法的对象, 比如<code>my_string.reverse()</code>, <code>my_string</code>就是receiver.<br><code>ancestors chain</code>就是 <code>receiver&#39;s Class -&gt; 父类 -&gt; 前者的父类 -&gt; ... -&gt; 直到Ruby的基类BasicObject</code>,这种继承关系就是了.</p>
<p>那么现在就可以解释这个过程了: 一个方法在被调用时, Ruby会首先在当前类中查找有没有这个方法, 没有找父类, 以此类推, 直到找到位置, 如果已经查找到了<code>BasicObject</code>仍不见这个方法, 那么Ruby就会抛异常:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NoMethodError: undefined method ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可以通过<code>ancestors</code> 来获取所有的祖先类:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySubclass.ancestors # =&gt; [MySubclass, MyClass, Object, Kernel, BasicObject]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是请注意这个Kernel在调用链中是做什么的呢?</p>
</blockquote>
<h4 id="Modules-and-Lookup"><a href="#Modules-and-Lookup" class="headerlink" title="Modules and Lookup"></a>Modules and Lookup</h4><blockquote>
<p>我们发现在Object和BasicObject之间被插进去了Kernel 这个module, 首先要说明一点调用链是包含module的, 不仅仅指的是class.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module M1</span><br><span class="line">  def my_method</span><br><span class="line">    &apos;M1#my_method()&apos;</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">class C</span><br><span class="line">  include M1</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">class D &lt; C; end</span><br><span class="line"></span><br><span class="line">D.ancestors # =&gt; [D, C, M1, Object, Kernel, BasicObject]</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>include</code> 方法是把mudule M1插入了方法调用链中, 它的特点是插入该类在调用链的后面位置, M1是C的祖先.<br>从Ruby2.0以后, 加入一个新的方法<code>prepend</code>, 它和<code>include</code>恰好相反, 其特点是插入该类在调用链的前面:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class C2</span><br><span class="line">  prepend M2</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">class D2 &lt; C2; end</span><br><span class="line"></span><br><span class="line">D2.ancestors # =&gt; [D2, M2, C2, Object, Kernel, BasicObject]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>下面的图反映了<code>include</code>和<code>prepend</code>的不同之处:</p>
<p><img src="http://i2.tietuku.com/40d72a7fbea95b59.png"></p>
</blockquote>
<h4 id="Multiple-Inclusions"><a href="#Multiple-Inclusions" class="headerlink" title="Multiple Inclusions"></a>Multiple Inclusions</h4><blockquote>
<p>这里我觉得书上貌似有些小问题, 我对于这种多次包含关系是针对的是以哪个module为准, 这个module指的是所定义的那个module :</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module M1; end</span><br><span class="line"></span><br><span class="line">module M2 </span><br><span class="line">  include M1</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">module M3</span><br><span class="line">  prepend M1</span><br><span class="line">  include M2</span><br><span class="line">end</span><br><span class="line">M1.ancestors # =&gt; [M1]</span><br><span class="line">M2.ancestors # =&gt; [M2, M1]</span><br><span class="line">M3.ancestors # =&gt; [M1, M3, M2]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>并不像书上说的谁覆盖掉谁那样.</p>
</blockquote>
<h4 id="The-Kernel"><a href="#The-Kernel" class="headerlink" title="The Kernel"></a>The Kernel</h4><blockquote>
<p>这个Kernel到底是做什么的, 为什么要放在Object 和 BasicObject之间呢? 下面就研究一下:<br>Ruby有一些方法比如<code>print</code>, <code>puts</code>你可以在任意地方使用, 好像每个对象都有<code>print</code>方法, 事实上像<code>print</code>这样方法就是这个<code>Kernel</code>的私有的实例方法(private instance method). </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kernel.private_instance_methods.grep(/^pr/) # =&gt; [:printf, :print, :proc]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>而Kernel又包含了Object, Kernel就在几乎所有对象的调用链中了, 所以你可以在任意地方使用<code>print</code>方法, 仿佛<code>print</code>是关键字, 但事实上它是方法, 很酷!<br>你甚至可以利用该机制, 结合前面学习的<code>Open Classes</code>, 打开Kernel, 添加方法, 给所有对象使用. 比如说我们使用的一些gem就这么做了, 看接下来的例子:</p>
</blockquote>
<h5 id="The-Awesome-Print-Example"><a href="#The-Awesome-Print-Example" class="headerlink" title="The Awesome Print Example"></a>The Awesome Print Example</h5><blockquote>
<p><code>awesome_print</code> gem 可以打印出带有缩进(indentation)的Ruby对象, 比如:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">require &quot;awesome_print&quot;</span><br><span class="line">local_time = &#123;:city =&gt; &quot;Rome&quot;, :now =&gt; Time.now &#125;</span><br><span class="line">ap local_time, :indent =&gt; 2</span><br><span class="line"></span><br><span class="line"># =&gt;</span><br><span class="line">&#123;</span><br><span class="line">  :city =&gt; &quot;Rome&quot;,</span><br><span class="line">  :now =&gt; 2013-11-30 12:51:03 +0100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ap</code>就是awesome_print gem提供的, 可以在任意地方使用, 原因就是它打开了Kernel, 添加了方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># gems/awesome_print-1.1.0/lib/awesome_print/core_ext/kernel.rb</span><br><span class="line">module Kernel</span><br><span class="line">  def ap(abject, options = &#123;&#125;)</span><br><span class="line">    ...</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="Method-Execution-方法执行"><a href="#Method-Execution-方法执行" class="headerlink" title="Method Execution(方法执行)"></a>Method Execution(方法执行)</h2><blockquote>
<p>现在找到了方法, 那么就看看第二件事, 执行方法. 试想一下你是Ruby的解释器, 某个调用<code>my_method</code>这个方法, 你马上向右然后在继承关系链上向上查找该方法, 假设<code>my_method</code>方法是这样定义的:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def my_method</span><br><span class="line">  temp = @x + 1</span><br><span class="line">  my_other_method(temp)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 要执行这个方法, 首先要弄清楚下面的2个问题: </p>
</blockquote>
<ul>
<li>实例变量属于什么对象?</li>
<li><code>my_other_method</code>应该在什么对象上调用?<blockquote>
<p>答案都是<code>receiver</code>.</p>
</blockquote>
</li>
</ul>
<h3 id="The-self-Keyword"><a href="#The-self-Keyword" class="headerlink" title="The self Keyword"></a>The self Keyword</h3><blockquote>
<p>当前被执行的代码所在的Ruby对象, 也就是当前对象(current object), 使用<code>self</code>关键字表示.<br>在给定时间内只有一个对象可以充当<code>self</code>的角色, 没有什么对象可以一直地充当这个角色. 当你在调用执行方法时, <code>receiver</code>就是self. 从这一刻起, 所有的实例变量就是<code>self</code>的实例变量, 所有的没有指定接收者的方法就是在<code>self</code>上调用的方法. 只要你的代码在某个对象上调用方法, 那么这个方法就变成了<code>self</code>.<br>下面的例子巧妙地解释了<code>self</code>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line">  def testing_self</span><br><span class="line">    @var = 10     # An instance variable of self</span><br><span class="line">    my_method()   # Same as self.my_method()</span><br><span class="line">    self</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def my_method</span><br><span class="line">    @var = @var + 1</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">obj = MyClass.new</span><br><span class="line">obj.testing_self  # =&gt; #&lt;MyClass:0x007f93ab08a728 @var=11&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>testing_self</code>方法一旦被调用, 接收者obj变为<code>self</code>. 进而<code>@var</code>就是<code>obj</code>的实例变量, <code>my_method</code>方法也在<code>obj</code>对象上调用. 当<code>my_method</code>被执行的时候, <code>obj</code>还是<code>self</code>, 所以, <code>@var</code>还是<code>obj</code>的实例变量. 最后<code>testing_self</code>返回<code>self</code></p>
<p>如果想要成为Ruby大师, 就应该时刻搞清楚哪个对象扮演<code>self</code>的角色. 大多数情况下很简单, 只需要弄清楚哪个对象是刚才方法的接收者. 但是需要知道下面的知识点:</p>
</blockquote>
<h4 id="The-Top-Level"><a href="#The-Top-Level" class="headerlink" title="The Top Level"></a>The Top Level</h4><blockquote>
<p>我们知道每当在一个对象上调用方法时, 该对象就变成了<code>self</code>. 但是如果没有调用任何方法的话谁是<code>self</code>, 我在irb上做了这样的实验:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># irb</span><br><span class="line">self      #=&gt; main</span><br><span class="line">self.class # =&gt; Object</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当开始运行一段Ruby程序的时候, Ruby解释器会创建一个叫做main的对象, 我们的需要就运行其中. 这个对象有时候被称为<code>top-level context</code>(顶级上下文).因为这个对象是你程序调用栈的最上层.<br>注意: 这个main和Java和C中的main方法没有任何关系.</p>
</blockquote>
<h4 id="Class-Definitions-and-self"><a href="#Class-Definitions-and-self" class="headerlink" title="Class Definitions and self"></a>Class Definitions and self</h4><blockquote>
<p>在class或者module定义中, <code>self</code>就是class和module本身:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line">  self #=&gt; MyClass</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>想想类方法的定义…</p>
</blockquote>
<h4 id="What-private-Really-Means"><a href="#What-private-Really-Means" class="headerlink" title="What private Really Means"></a>What private Really Means</h4><blockquote>
<p>现在学习了<code>self</code>, 就应该对Ruby的private关键字有新的认识了. Private方法遵循一个原则: 你不能使用一个明确的接收者来调用private 方法. 也就是说你每次调用private 方法的时候, 它一定有一个隐含的接收者<code>self</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class C</span><br><span class="line">  def public_method</span><br><span class="line">    self.private_method</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line"></span><br><span class="line">  def private_method; end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">C.new.public_method</span><br><span class="line"># =&gt; NoMethodError: private method ‘private_method’ called [...]</span><br></pre></td></tr></table></figure></p>
<p>如果去掉<code>self</code>程序就会通过.<br>这个牵强的例子说明了私有方法的两个必要条件:</p>
<ul>
<li>当接收者不是你自己时, 必须要明确指定接收者</li>
<li>私有方法需要在隐含接收者上被调用</li>
</ul>
<p>想想之前提到的<code>puts</code>和<code>print</code>, 它们是Module <code>Kernel</code>的私有方法, 我们使用这些方法是从来没有明确指定接收者.</p>
<p>总而言之, 调用私有方法是永远不要指定接收者, 还有, 我们可以调用父类的私有方法.</p>
</blockquote>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><blockquote>
<p>到目前为止, 方法的执行可以总结为几句话: 你调用方法时, Ruby以<code>向右一步, 一直向上</code>的原则来查找方法, 然后把方法接收者作为self执行方法. 有一些特殊情况, 比如<code>include module</code>, 而且有一个意外情况!(Refinements)</p>
</blockquote>
<h3 id="Refinements-改进"><a href="#Refinements-改进" class="headerlink" title="Refinements(改进)"></a>Refinements(改进)</h3><blockquote>
<p>我们在<code>Open Classes</code>时, 打开String 添加过一个方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># object_model/alphanumeric.rb</span><br><span class="line"></span><br><span class="line">class String</span><br><span class="line">  def to_alphanumeric</span><br><span class="line">    self.gsub(/[^\w\s]/, &apos;&apos;)</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这么修改是全局的, 也就是说每个String都会发生变化.还说过如果方法名和原来的一样, 就会覆盖掉之前的方法, 这一节的知识就是为了解决这个问题.<br>Ruby2.0开始引入了Refinement, 它把我们要修改的类约束在了一个范围内:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># object_model/refinements_in_module.rb</span><br><span class="line">module StringExtensions</span><br><span class="line">  refine String do</span><br><span class="line">    def to_alphanumeric</span><br><span class="line">      self.gsub(/[^\w\s]/, &apos;&apos;)</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>调用时需要使用<code>using</code>指定这个范围:</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">using StringExtensions</span><br><span class="line"></span><br><span class="line"><span class="string">"my *1st* refinement!"</span>.to_alphanumeric <span class="comment"># =&gt; "my 1st refinement"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>从Ruby2.1开始, 可以在module的定义中使用<code>using</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">require_relative &apos;../test/assertions&apos;</span><br><span class="line"></span><br><span class="line">module StringExtensions</span><br><span class="line">  refine String do</span><br><span class="line">    def reverse</span><br><span class="line">      &quot;esrever&quot;</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">module StringStuff</span><br><span class="line">  using StringExtensions</span><br><span class="line">  &quot;my_string&quot;.reverse    # =&gt; &quot;esrever&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">&quot;my_string&quot;.reverse      # =&gt; &quot;gnirts_ym&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可见, Refinements和Monkeypatches很接近, 但是不是全局的. 它只在两个地方是激活的, <code>refine</code>方法的block中, 还有调用<code>using</code>后面的代码.<br>Refinements和Monkeypatches的作用是一样的, 定义新方法, 改进已经存在的方法, include或者prepend modules. 他就像是给源代码打了一个补丁.<br>另一方面, Refinements不是全局的, 不会影响你程序剩余的部分.</p>
</blockquote>
<h5 id="Refinement-Gotchas-需要注意"><a href="#Refinement-Gotchas-需要注意" class="headerlink" title="Refinement Gotchas (需要注意)"></a>Refinement Gotchas (需要注意)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line">  def my_method</span><br><span class="line">    &quot;original my_method()&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def another_method</span><br><span class="line">    my_method</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">module MyClassRefinement</span><br><span class="line">  refine MyClass do</span><br><span class="line">    def my_method</span><br><span class="line">      &quot;refined my_method()&quot;</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">using MyClassRefinement</span><br><span class="line">puts MyClass.new.my_method # =&gt; refined my_method()</span><br><span class="line">puts MyClass.new.another_method  # =&gt; original my_method()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里是一个特别的地方, <code>another_method</code>方法调用了<code>my_method</code>, 虽然也是在 using 后面, 它返回的还是原来方法的结果.</p>
</blockquote>
<h2 id="Quiz-Tangle-of-Modules-modules-混在一起"><a href="#Quiz-Tangle-of-Modules-modules-混在一起" class="headerlink" title="Quiz: Tangle of Modules (modules 混在一起)"></a>Quiz: Tangle of Modules (modules 混在一起)</h2><blockquote>
<p>有这样一个例子:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">module Printable</span><br><span class="line">  def print</span><br><span class="line">    </span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def prepare_cover</span><br><span class="line">    </span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">module Document</span><br><span class="line">  def print_to_screen</span><br><span class="line">    prepare_cover</span><br><span class="line">    format_for_screen</span><br><span class="line">    print</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def format_for_screen</span><br><span class="line">    </span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def print</span><br><span class="line">    </span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">class Book</span><br><span class="line">  include Document</span><br><span class="line">  include Printable</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">b = Book.new</span><br><span class="line">b.print_to_screen</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请问: <code>print_to_screen</code>中的<code>print</code> 来自于哪个module? 是<code>Printable</code>还是<code>Document</code>还是<code>Kernel</code>?<br>答案是: Printable.<br>既然是在Book的对象b上调用的方法, 那么就看看Book的祖先类的调用链.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Book.ancestors # =&gt; [Book, Printable, Document, Object, Kernel, BasicObject]</span><br></pre></td></tr></table></figure></p>
<p>由于Book中先执行<code>include Document</code>, 然后<code>include Printable</code>, 所以Printable被加到了Book的右侧, Document次之. 当你调用<code>b.print_to_screen</code>方法时, 对象的引用<code>b</code>被看作为<code>self</code>, 然后查找方法就开始了, Ruby发现<code>print_to_screen</code>在<code>Document</code>中, <code>print_to_screen</code>方法中还调用了别的方法, 包括<code>print</code>, 而且现在还没有指定接收者, 那么接收者还是<code>b</code>, 方法lookup还好从<code>Book</code>开始, 所以<code>print</code>当然是从<code>Printable</code>找到的了, 因为<code>Printable</code>在调用链上离<code>Book</code>最近.<br>如果现在希望使用Document的<code>print</code>方法, 应该在Book中先<code>include Printable</code>在<code>include Document</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Book</span><br><span class="line">  include Printable</span><br><span class="line">  include Document</span><br><span class="line">  ancestors # =&gt; [Book, Document, Printable, Object, Kernel, BasicObject]  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="Wrap-Up-总结"><a href="#Wrap-Up-总结" class="headerlink" title="Wrap-Up(总结)"></a>Wrap-Up(总结)</h2><blockquote>
<p>这个列表总结了第二章的所有内容:</p>
</blockquote>
<ul>
<li><p>对象是由一堆实例变量和一个class的链接组成的(引用)</p>
</li>
<li><p>对象的方法存于对象的类中</p>
</li>
<li><p>class 本身是<code>Class</code>的对象, class的名称仅仅是个常量</p>
</li>
<li><p>Class是Module的子类, module可以理解为方法的包(集合). class可以被实例化, 或者组织到继承关系中</p>
</li>
<li><p>Constants被组织成了类似于文件系统的树状结构, module或者类的名字是文件系统的目录, 普通的Constants则是文件.</p>
</li>
<li><p>每一个class都有一个祖先链, 从该class开始, 到<code>BasicObject</code>结束.</p>
</li>
<li><p>当你在一个对象身上调用方法的时候, Ruby先向右找到接收者(对象)所属的类, 然后一直验证祖先链向上查找这个方法. 直到在链子上找到方法为止.</p>
</li>
<li><p>当你在一个class中include一个module时,这个module会被插到该class的祖先链该class的正上方位置.<code>prepend</code>方法是插到正下方.</p>
</li>
<li><p>当你调用方法时, 接收者充当<code>self</code>的角色</p>
</li>
<li><p>当你定义module(或class)时, module充当<code>self</code>的角色</p>
</li>
<li><p>实例变量一直被作为<code>self</code>的实例变量</p>
</li>
<li><p>任何没有明确指定接收者的方法都会被认为是<code>self</code>的方法.</p>
</li>
<li><p>Refinements 像是class上的代码补丁, 它覆盖了普通的方法查找(lookup). 另外, Refinement仅仅在程序的限制区域内生效, 这个区域是<code>using XXX</code>到文件结尾或者module的定义结尾.</p>
</li>
</ul>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="Daniel Zhang" />
          <p class="site-author-name" itemprop="name">Daniel Zhang</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">105</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">104</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Daniel Zhang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
